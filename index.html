<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
        canvas#sprite-canvas { /* Target main canvas */
            border: 1px solid #d1d5db; /* gray-300 */
            cursor: default; /* Default cursor, change on hover/drag */
            touch-action: none; /* Prevent default touch actions like scrolling */
            background-color: #f9fafb; /* Add a light background */
        }
        .frame-image:hover {
             cursor: grab;
        }
        canvas:active {
            /* cursor: grabbing; */ /* Set dynamically in JS */
        }
        .control-panel label,
        .modal-content label,
        #animation-preview-container label { /* Apply label style */
            @apply block text-sm font-medium text-gray-700 mb-1;
        }

        /* --- Custom CSS Input Styles (Applied via .gui-input class) --- */
        .gui-input {
            display: block;
            width: 100%;
            padding: 0.5rem; /* p-2 */
            font-size: 0.875rem; /* text-sm */
            color: #1f2937; /* gray-800 */
            background-color: #ffffff; /* bg-white */
            border: 1px solid #9ca3af; /* gray-400 */
             /* Classic bevel effect borders - slightly different for inset feel */
            border-top-color: #6b7280; /* gray-500 */
            border-left-color: #6b7280; /* gray-500 */
            border-bottom-color: #e5e7eb; /* gray-200 */
            border-right-color: #e5e7eb; /* gray-200 */
            border-radius: 0.25rem; /* rounded */
            transition: border-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }
        /* Removed spinner hiding rules */

        /* Custom focus style for inputs */
         .gui-input:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            /* Replicate Tailwind focus ring using box-shadow */
            box-shadow: 0 0 0 2px #ffffff, 0 0 0 4px #6366f1; /* ring-2 ring-indigo-500 ring-offset-2 */
            border-color: #6366f1; /* focus:border-indigo-500 */
         }
        /* --- End of Custom Input Styles --- */

        /* --- Custom CSS Button Styles --- */
        .gui-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem; /* Equivalent to px-4 py-2 */
            font-size: 0.875rem; /* Equivalent to text-sm */
            font-weight: 500; /* Equivalent to font-medium */
            color: #1f2937; /* gray-800 */
            background-color: #f3f4f6; /* gray-100 - Base solid color */
            border: 1px solid #9ca3af; /* gray-400 */
            /* Classic bevel effect borders */
            border-top-color: #e5e7eb; /* gray-200 */
            border-left-color: #e5e7eb; /* gray-200 */
            border-bottom-color: #6b7280; /* gray-500 */
            border-right-color: #6b7280; /* gray-500 */
            border-radius: 0.25rem; /* Equivalent to rounded */
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.1s ease-in-out, border-style 0.1s ease-in-out;
            /* Focus styles (Tailwind classes for consistency) */
            @apply focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2;
        }

        .gui-button:hover {
            background-color: #e5e7eb; /* gray-200 */
        }

        .gui-button:active {
            background-color: #d1d5db; /* gray-300 */
            border-style: inset; /* Inset border on click */
        }

        .gui-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Ensure icons align vertically */
         .gui-button .lucide {
             vertical-align: middle;
         }
         /* Keep margin for modal secondary button */
         .modal-content button#cancel-import-sheet {
             margin-left: 0.75rem; /* ml-3 */
         }
         /* --- End of Custom Button Styles --- */

        /* Style for the message box */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 8px; /* More rounded */
            display: none; /* Hidden by default */
            z-index: 1050; /* Ensure it's above modal overlay */
            max-width: 90%;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Below message box, above content */
        }
        .modal-content {
            background-color: white;
            padding: 2rem; /* More padding */
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw; /* Limit width */
            max-height: 90vh; /* Limit height */
            overflow-y: auto; /* Allow scrolling if content overflows */
            width: 500px; /* Default width */
        }
        .modal-content h2 {
             @apply text-xl font-semibold text-gray-900 mb-4;
        }
        /* Use Tailwind for modal inputs for simplicity */
        .modal-content input[type="number"] {
             @apply block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2 mb-3;
        }
        /* Style for the preview canvas */
        #sprite-sheet-preview-canvas {
            max-width: 100%;
            border: 1px solid #d1d5db; /* gray-300 */
            margin-bottom: 1rem;
            display: block; /* Ensure it behaves like a block element */
            margin-left: auto; /* Center preview */
            margin-right: auto;
            background-color: #f8f8f8; /* Light background for canvas */
        }

        /* Selection Highlight */
        .selected-frame-highlight {
            position: absolute; /* Position relative to canvas container */
            border: 2px solid #4f46e5; /* Indigo-600 */
            box-shadow: 0 0 0 2px white; /* Inner white glow for contrast */
            pointer-events: none; /* Don't interfere with clicks */
            z-index: 10; /* Above images */
        }

        /* Animation Preview Styles */
        #animation-preview-container {
            @apply mt-6 pt-4 border-t border-gray-200; /* Add separator */
        }
        #animation-preview-canvas {
            border: 1px solid #d1d5db; /* gray-300 */
            background-color: #f0f0f0; /* Slightly different background */
            display: block; /* Prevent extra space below */
            margin-left: auto; /* Center */
            margin-right: auto;
            margin-top: 0.5rem; /* Space below label */
        }

    </style>
    <style>
      @font-face {
        font-family: 'LucideIcons';
        src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
      }
      .lucide {
        font-family: 'LucideIcons';
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-rendering: auto;
        line-height: 1;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        display: inline-block; /* Ensure proper alignment */
        margin-right: 0.5em; /* Space between icon and text */
      }
      .lucide-upload::before { content: "\e90b"; } /* upload icon */
      .lucide-save::before { content: "\e8b4"; } /* save icon */
      .lucide-file-image::before { content: "\e9f0"; } /* file-image icon */
      .lucide-trash-2::before { content: "\e8ed"; } /* trash-2 icon */
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="container mx-auto max-w-4xl bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-semibold text-gray-900 mb-6 text-center">Sprite Sheet Editor</h1>

        <div class="control-panel grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 items-end">
            <div>
                <label for="grid-cols">Grid Columns:</label>
                <input type="number" id="grid-cols" class="gui-input" value="4" min="1">
            </div>
            <div>
                <label for="grid-rows">Grid Rows:</label>
                <input type="number" id="grid-rows" class="gui-input" value="4" min="1">
            </div>
            <div>
                <label for="frame-width">Frame Width (px):</label>
                <input type="number" id="frame-width" class="gui-input" value="64" min="1">
            </div>
            <div>
                <label for="frame-height">Frame Height (px):</label>
                <input type="number" id="frame-height" class="gui-input" value="64" min="1">
            </div>
            <div class="col-span-2 md:col-span-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mt-4">
                 <button id="import-frames-button" class="gui-button">
                    <span class="lucide lucide-upload"></span>Import Frames
                </button>
                 <button id="import-sheet-button" class="gui-button">
                    <span class="lucide lucide-file-image"></span>Import Sheet
                </button>
                 <button id="delete-frame-button" class="gui-button" disabled> <span class="lucide lucide-trash-2"></span>Delete Frame
                 </button>
                <button id="save-button" class="gui-button">
                     <span class="lucide lucide-save"></span>Save Sprite Sheet
                </button>
            </div>
        </div>

        <input type="file" id="frame-file-input" multiple accept="image/*" class="hidden">
        <input type="file" id="sheet-file-input" accept="image/*" class="hidden">

        <div id="canvas-container" class="relative w-full overflow-auto border border-gray-300 rounded-md bg-gray-50" style="max-height: 60vh;">
             <canvas id="sprite-canvas" class="block rounded-md"></canvas>
             </div>

        <div id="animation-preview-container">
            <label for="animation-preview-canvas" class="text-center block">Animation Preview</label>
            <canvas id="animation-preview-canvas"></canvas>
            </div>

        <div id="message-box"></div>

        <div id="import-sheet-modal" class="modal-overlay hidden">
             <div class="modal-content">
                 <h2>Import Sprite Sheet</h2>
                 <canvas id="sprite-sheet-preview-canvas"></canvas>
                 <p class="text-sm text-gray-600 mb-4">Adjust the grid dimensions or frame size. The other values will update automatically.</p>
                 <div class="grid grid-cols-2 gap-4">
                     <div>
                         <label for="import-sheet-cols">Grid Columns:</label>
                         <input type="number" id="import-sheet-cols" class="gui-input mb-3" value="4" min="1" step="1">
                     </div>
                     <div>
                         <label for="import-sheet-rows">Grid Rows:</label>
                         <input type="number" id="import-sheet-rows" class="gui-input mb-3" value="4" min="1" step="1">
                     </div>
                     <div>
                         <label for="import-sheet-width">Frame Width (px):</label>
                         <input type="number" id="import-sheet-width" class="gui-input mb-3" value="64" min="1" step="1">
                     </div>
                     <div>
                         <label for="import-sheet-height">Frame Height (px):</label>
                         <input type="number" id="import-sheet-height" class="gui-input mb-3" value="64" min="1" step="1">
                     </div>
                 </div>
                 <div class="mt-6 text-right">
                      <button id="cancel-import-sheet" class="gui-button">Cancel</button>
                      <button id="load-sheet-button" class="gui-button">Load Sprite Sheet</button>
                 </div>
             </div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('sprite-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        const gridColsInput = document.getElementById('grid-cols');
        const gridRowsInput = document.getElementById('grid-rows');
        const frameWidthInput = document.getElementById('frame-width');
        const frameHeightInput = document.getElementById('frame-height');
        const importFramesButton = document.getElementById('import-frames-button');
        const importSheetButton = document.getElementById('import-sheet-button');
        const saveButton = document.getElementById('save-button');
        const deleteFrameButton = document.getElementById('delete-frame-button');
        const frameFileInput = document.getElementById('frame-file-input');
        const sheetFileInput = document.getElementById('sheet-file-input');
        const messageBox = document.getElementById('message-box');
        const importSheetModal = document.getElementById('import-sheet-modal');
        // Modal specific elements
        const modalPreviewCanvas = document.getElementById('sprite-sheet-preview-canvas'); // Renamed for clarity
        const modalPreviewCtx = modalPreviewCanvas.getContext('2d');
        let importSheetColsInput = document.getElementById('import-sheet-cols');
        let importSheetRowsInput = document.getElementById('import-sheet-rows');
        let importSheetWidthInput = document.getElementById('import-sheet-width');
        let importSheetHeightInput = document.getElementById('import-sheet-height');
        const cancelImportSheetButton = document.getElementById('cancel-import-sheet');
        const loadSheetButton = document.getElementById('load-sheet-button');
        // Animation Preview elements
        const animationPreviewCanvas = document.getElementById('animation-preview-canvas');
        const animationPreviewCtx = animationPreviewCanvas.getContext('2d');


        // --- State Variables ---
        let gridCols = parseInt(gridColsInput.value);
        let gridRows = parseInt(gridRowsInput.value);
        let frameWidth = parseInt(frameWidthInput.value);
        let frameHeight = parseInt(frameHeightInput.value);
        let placedImages = [];
        let nextImageId = 0;
        let selectedFrameId = null;
        let sourceSpriteSheetImage = null;
        // Modal Preview canvas state
        let modalPreviewScaleFactor = 1;
        let modalPreviewOffsetX = 0;
        let modalPreviewOffsetY = 0;
        let modalPreviewDrawnWidth = 0;
        let modalPreviewDrawnHeight = 0;
        let isUpdatingInputs = false;
        // Animation state
        let animationIntervalId = null;
        let currentAnimationFrameIndex = 0;
        let animationFps = 10; // Frames per second
        let framesToAnimate = [];


        // --- Drag and Drop State ---
        let isDragging = false;
        let dragMoved = false;
        let draggedImage = null;
        let startX, startY;
        let dragStartX, dragStartY;
        let offsetX, offsetY;

        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            if (messageBox.timeoutId) clearTimeout(messageBox.timeoutId);
            messageBox.timeoutId = setTimeout(() => {
                messageBox.style.display = 'none';
                messageBox.timeoutId = null;
            }, duration);
        }

        // --- Selection Highlight ---
        let selectionHighlight = null;
        function createSelectionHighlight() {
            if (!selectionHighlight) {
                selectionHighlight = document.createElement('div');
                selectionHighlight.className = 'selected-frame-highlight hidden';
                canvasContainer.appendChild(selectionHighlight);
            }
        }
        function updateSelectionHighlight() {
            if (!selectionHighlight) createSelectionHighlight();
            if (selectedFrameId !== null) {
                const selectedItem = placedImages.find(item => item.id === selectedFrameId);
                if (selectedItem) {
                    selectionHighlight.style.left = `${selectedItem.col * frameWidth}px`;
                    selectionHighlight.style.top = `${selectedItem.row * frameHeight}px`;
                    selectionHighlight.style.width = `${frameWidth}px`;
                    selectionHighlight.style.height = `${frameHeight}px`;
                    selectionHighlight.classList.remove('hidden');
                    deleteFrameButton.disabled = false; return;
                }
            }
            selectionHighlight.classList.add('hidden');
            deleteFrameButton.disabled = true;
        }

        // --- Canvas Drawing ---
        function drawGrid() {
             try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
                for (let i = 0; i <= gridCols; i++) {
                    ctx.beginPath(); ctx.moveTo(i * frameWidth, 0); ctx.lineTo(i * frameWidth, canvas.height); ctx.stroke();
                }
                for (let i = 0; i <= gridRows; i++) {
                    ctx.beginPath(); ctx.moveTo(0, i * frameHeight); ctx.lineTo(canvas.width, i * frameHeight); ctx.stroke();
                }
            } catch (e) { console.error("Error drawing grid:", e); showMessage("Error rendering grid.", 5000); }
        }

        function drawImages() {
             try {
                canvas.style.cursor = 'default';
                placedImages.forEach(item => {
                    const drawX = item.col * frameWidth; const drawY = item.row * frameHeight;
                    if (item && item.img && item.img.complete) {
                        if (!isDragging || item.id !== draggedImage?.id) {
                            ctx.drawImage(item.img, drawX, drawY, frameWidth, frameHeight);
                        }
                    } else if (item && item.img && !item.img.complete) {
                        ctx.fillStyle = '#f3f4f6'; ctx.fillRect(drawX + 2, drawY + 2, frameWidth - 4, frameHeight - 4);
                        ctx.fillStyle = '#9ca3af'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText('Loading...', drawX + frameWidth / 2, drawY + frameHeight / 2);
                    }
                });
                if (isDragging && draggedImage && draggedImage.img && draggedImage.img.complete) {
                    ctx.globalAlpha = 0.6;
                    ctx.drawImage(draggedImage.img, startX - offsetX, startY - offsetY, frameWidth, frameHeight);
                    ctx.globalAlpha = 1.0; canvas.style.cursor = 'grabbing';
                }
             } catch (e) { console.error("Error drawing images:", e); showMessage("Error rendering images.", 5000); if (isDragging) { isDragging = false; draggedImage = null; canvas.style.cursor = 'default'; } }
        }

        function redrawCanvas() {
             try {
                const newCanvasWidth = gridCols * frameWidth; const newCanvasHeight = gridRows * frameHeight;
                if (newCanvasWidth <= 0 || newCanvasHeight <= 0 || !Number.isFinite(newCanvasWidth) || !Number.isFinite(newCanvasHeight)) {
                    console.warn("Skipping redraw: invalid dimensions", newCanvasWidth, newCanvasHeight);
                    if (canvas.width > 0 && canvas.height > 0) ctx.clearRect(0, 0, canvas.width, canvas.height);
                     // Also clear/stop animation preview if dimensions are invalid
                     animationPreviewCanvas.width = 1; animationPreviewCanvas.height = 1; // Minimal size
                     animationPreviewCtx.clearRect(0, 0, 1, 1);
                     stopAnimation();
                    return;
                }
                if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {
                    canvas.width = newCanvasWidth; canvas.height = newCanvasHeight;
                    canvas.style.width = `${newCanvasWidth}px`; canvas.style.height = `${newCanvasHeight}px`;
                }

                // Resize animation preview canvas
                if (animationPreviewCanvas.width !== frameWidth || animationPreviewCanvas.height !== frameHeight) {
                    animationPreviewCanvas.width = frameWidth > 0 ? frameWidth : 1;
                    animationPreviewCanvas.height = frameHeight > 0 ? frameHeight : 1;
                    // Restart animation after resize
                    startAnimation();
                }

                drawGrid();
                drawImages();
                updateSelectionHighlight();
            } catch (e) { console.error("Error in redrawCanvas:", e); showMessage("Error updating canvas.", 5000); }
        }

        // --- Event Handlers ---
        function handleSizeChange() {
            const newCols = parseInt(gridColsInput.value); const newRows = parseInt(gridRowsInput.value);
            const newFrameW = parseInt(frameWidthInput.value); const newFrameH = parseInt(frameHeightInput.value);
            if (isNaN(newCols) || isNaN(newRows) || isNaN(newFrameW) || isNaN(newFrameH) || newCols < 1 || newRows < 1 || newFrameW < 1 || newFrameH < 1) {
                showMessage("Invalid size: values must be positive numbers.");
                gridColsInput.value = gridCols; gridRowsInput.value = gridRows; frameWidthInput.value = frameWidth; frameHeightInput.value = frameHeight; return;
            }
            gridCols = newCols; gridRows = newRows; frameWidth = newFrameW; frameHeight = newFrameH;
            const oldSelectedId = selectedFrameId;
            placedImages = placedImages.filter(item => item.row < gridRows && item.col < gridCols);
            if (oldSelectedId !== null && !placedImages.some(item => item.id === oldSelectedId)) { selectedFrameId = null; }
            redrawCanvas(); // This will also resize preview and restart animation
        }

        // --- Frame Import ---
        function handleImportFramesClick() { frameFileInput.click(); }
        function handleFrameFileSelect(event) {
            const files = event.target.files; if (!files.length) return;
            let imagesSuccessfullyLoaded = 0, imagesFailedToLoad = 0, slotsAttempted = 0, totalFiles = files.length;
            let slotsAvailable = gridRows * gridCols - placedImages.length;
            function findNextAvailableSlot() { for (let r = 0; r < gridRows; r++) for (let c = 0; c < gridCols; c++) if (!placedImages.some(img => img.row === r && img.col === c)) return { row: r, col: c }; return null; }
            if (totalFiles > slotsAvailable) showMessage(`Attempting ${totalFiles} frames, only ${slotsAvailable} slots empty.`, 4000);
            Array.from(files).forEach((file) => {
                slotsAttempted++; const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = () => {
                        const slot = findNextAvailableSlot();
                        if (slot) {
                             placedImages.push({ img: img, row: slot.row, col: slot.col, id: nextImageId++ });
                             imagesSuccessfullyLoaded++;
                             redrawCanvas(); // Redraw main canvas
                             startAnimation(); // Update animation sequence
                        } else { imagesFailedToLoad++; console.warn(`No slot for ${file.name}`); }
                        if (imagesSuccessfullyLoaded + imagesFailedToLoad === totalFiles) showMessage(`Frame import: ${imagesSuccessfullyLoaded} loaded, ${imagesFailedToLoad} skipped.`, 4000);
                    };
                    img.onerror = () => { console.error(`Failed load frame: ${file.name}`); imagesFailedToLoad++; if (imagesSuccessfullyLoaded + imagesFailedToLoad === totalFiles) showMessage(`Frame import: ${imagesSuccessfullyLoaded} loaded, ${imagesFailedToLoad} skipped.`, 4000); };
                    img.src = e.target.result;
                };
                reader.onerror = () => { console.error(`Failed read frame file: ${file.name}`); imagesFailedToLoad++; if (imagesSuccessfullyLoaded + imagesFailedToLoad === totalFiles) showMessage(`Frame import: ${imagesSuccessfullyLoaded} loaded, ${imagesFailedToLoad} skipped.`, 4000); };
                reader.readAsDataURL(file);
            });
            frameFileInput.value = '';
        }

        // --- Sprite Sheet Import ---
        function handleImportSheetClick() { sheetFileInput.click(); }

        // --- Update Modal Preview Grid and Inputs ---
        function updateModalPreviewGridAndInputs(changedInputId) { // Renamed function
            if (isUpdatingInputs || !sourceSpriteSheetImage || !sourceSpriteSheetImage.complete) return;
            isUpdatingInputs = true;
            // ... (Calculations remain the same) ...
            const currentCols = parseInt(importSheetColsInput.value); const currentRows = parseInt(importSheetRowsInput.value); const currentWidth = parseInt(importSheetWidthInput.value); const currentHeight = parseInt(importSheetHeightInput.value);
            const imgWidth = sourceSpriteSheetImage.width; const imgHeight = sourceSpriteSheetImage.height;
            try {
                if (changedInputId === 'import-sheet-cols' || changedInputId === 'import-sheet-rows') { if (currentCols > 0 && currentRows > 0) { const newFrameW = Math.floor(imgWidth / currentCols); const newFrameH = Math.floor(imgHeight / currentRows); if (newFrameW > 0 && !isNaN(newFrameW)) importSheetWidthInput.value = newFrameW; if (newFrameH > 0 && !isNaN(newFrameH)) importSheetHeightInput.value = newFrameH; } }
                else if (changedInputId === 'import-sheet-width' || changedInputId === 'import-sheet-height') { if (currentWidth > 0 && currentHeight > 0) { const newCols = Math.floor(imgWidth / currentWidth); const newRows = Math.floor(imgHeight / currentHeight); if (newCols > 0 && !isNaN(newCols)) importSheetColsInput.value = newCols; if (newRows > 0 && !isNaN(newRows)) importSheetRowsInput.value = newRows; } }
            } catch (e) { console.error("Error during dimension recalculation:", e); }

            // --- Redraw Modal Preview Canvas ---
            try {
                modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height);
                modalPreviewCtx.drawImage(sourceSpriteSheetImage, modalPreviewOffsetX, modalPreviewOffsetY, modalPreviewDrawnWidth, modalPreviewDrawnHeight);
                const finalCols = parseInt(importSheetColsInput.value); const finalRows = parseInt(importSheetRowsInput.value); const finalFrameW = parseInt(importSheetWidthInput.value); const finalFrameH = parseInt(importSheetHeightInput.value);
                if (isNaN(finalCols) || isNaN(finalRows) || isNaN(finalFrameW) || isNaN(finalFrameH) || finalCols < 1 || finalRows < 1 || finalFrameW < 1 || finalFrameH < 1) { console.warn("Invalid dimensions for preview grid."); isUpdatingInputs = false; return; }
                const previewFrameW = finalFrameW * modalPreviewScaleFactor; const previewFrameH = finalFrameH * modalPreviewScaleFactor;
                modalPreviewCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; modalPreviewCtx.lineWidth = 1;
                for (let i = 1; i < finalCols; i++) { const x = modalPreviewOffsetX + i * previewFrameW; modalPreviewCtx.beginPath(); modalPreviewCtx.moveTo(x, modalPreviewOffsetY); modalPreviewCtx.lineTo(x, modalPreviewOffsetY + modalPreviewDrawnHeight); modalPreviewCtx.stroke(); }
                for (let i = 1; i < finalRows; i++) { const y = modalPreviewOffsetY + i * previewFrameH; modalPreviewCtx.beginPath(); modalPreviewCtx.moveTo(modalPreviewOffsetX, y); modalPreviewCtx.lineTo(modalPreviewOffsetX + modalPreviewDrawnWidth, y); modalPreviewCtx.stroke(); }
            } catch (e) { console.error("Error drawing preview grid:", e); }
            isUpdatingInputs = false;
        }

        function handleSheetFileSelect(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                sourceSpriteSheetImage = new Image();
                sourceSpriteSheetImage.onload = () => {
                    // --- Draw image to MODAL preview canvas ---
                    const maxWidth = 450; const maxHeight = 300;
                    const imgWidth = sourceSpriteSheetImage.width; const imgHeight = sourceSpriteSheetImage.height;
                    const widthScale = maxWidth / imgWidth; const heightScale = maxHeight / imgHeight;
                    modalPreviewScaleFactor = Math.min(widthScale, heightScale, 1); // Use modal scale factor
                    modalPreviewDrawnWidth = imgWidth * modalPreviewScaleFactor; modalPreviewDrawnHeight = imgHeight * modalPreviewScaleFactor;
                    modalPreviewCanvas.width = modalPreviewDrawnWidth > 0 ? modalPreviewDrawnWidth : maxWidth; // Use modal canvas
                    modalPreviewCanvas.height = modalPreviewDrawnHeight > 0 ? modalPreviewDrawnHeight : maxHeight;
                    modalPreviewOffsetX = (modalPreviewCanvas.width - modalPreviewDrawnWidth) / 2; modalPreviewOffsetY = (modalPreviewCanvas.height - modalPreviewDrawnHeight) / 2;
                    modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height);
                    modalPreviewCtx.drawImage(sourceSpriteSheetImage, modalPreviewOffsetX, modalPreviewOffsetY, modalPreviewDrawnWidth, modalPreviewDrawnHeight);
                    // --- End modal preview drawing ---

                    // ... (Guessing dimensions remains the same) ...
                    const aspect = imgWidth / imgHeight; let guessCols = 4, guessRows = 4; if (aspect > 1.5 && imgHeight > 0) { guessCols = 8; guessRows = Math.max(1, Math.round(8 / aspect)); } else if (aspect < 0.6 && imgWidth > 0) { guessRows = 8; guessCols = Math.max(1, Math.round(8 * aspect)); } let guessFrameW = (guessCols > 0) ? Math.floor(imgWidth / guessCols) : imgWidth; let guessFrameH = (guessRows > 0) ? Math.floor(imgHeight / guessRows) : imgHeight; if (guessFrameW <= 0) guessFrameW = 1; if (guessFrameH <= 0) guessFrameH = 1; if (guessCols <= 0) guessCols = Math.max(1, Math.floor(imgWidth / guessFrameW)); if (guessRows <= 0) guessRows = Math.max(1, Math.floor(imgHeight / guessFrameH));
                    importSheetColsInput.value = guessCols; importSheetRowsInput.value = guessRows; importSheetWidthInput.value = guessFrameW; importSheetHeightInput.value = guessFrameH;

                    // ... (Cloning and adding listeners remains the same) ...
                    const newColsInput = importSheetColsInput.cloneNode(true); importSheetColsInput.parentNode.replaceChild(newColsInput, importSheetColsInput); importSheetColsInput = newColsInput;
                    const newRowsInput = importSheetRowsInput.cloneNode(true); importSheetRowsInput.parentNode.replaceChild(newRowsInput, importSheetRowsInput); importSheetRowsInput = newRowsInput;
                    const newWidthInput = importSheetWidthInput.cloneNode(true); importSheetWidthInput.parentNode.replaceChild(newWidthInput, importSheetWidthInput); importSheetWidthInput = newWidthInput;
                    const newHeightInput = importSheetHeightInput.cloneNode(true); importSheetHeightInput.parentNode.replaceChild(newHeightInput, importSheetHeightInput); importSheetHeightInput = newHeightInput;
                    importSheetColsInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-cols')); importSheetRowsInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-rows')); importSheetWidthInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-width')); importSheetHeightInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-height'));

                    updateModalPreviewGridAndInputs(null); // Update modal preview
                    importSheetModal.classList.remove('hidden');
                };
                sourceSpriteSheetImage.onerror = () => { showMessage("Error: Could not load image file.", 5000); sourceSpriteSheetImage = null; };
                sourceSpriteSheetImage.src = e.target.result;
            }
            reader.onerror = () => { showMessage("Error: Could not read file.", 5000); }
            reader.readAsDataURL(file);
            sheetFileInput.value = '';
        }

        function handleCancelImportSheet() {
            importSheetModal.classList.add('hidden');
            sourceSpriteSheetImage = null;
            modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height); // Use modal context
            // ... (Cloning to remove listeners remains the same) ...
            const cleanCols = importSheetColsInput.cloneNode(true); importSheetColsInput.parentNode.replaceChild(cleanCols, importSheetColsInput); importSheetColsInput = cleanCols; const cleanRows = importSheetRowsInput.cloneNode(true); importSheetRowsInput.parentNode.replaceChild(cleanRows, importSheetRowsInput); importSheetRowsInput = cleanRows; const cleanWidth = importSheetWidthInput.cloneNode(true); importSheetWidthInput.parentNode.replaceChild(cleanWidth, importSheetWidthInput); importSheetWidthInput = cleanWidth; const cleanHeight = importSheetHeightInput.cloneNode(true); importSheetHeightInput.parentNode.replaceChild(cleanHeight, importSheetHeightInput); importSheetHeightInput = cleanHeight;
        }

        function handleLoadSpriteSheet() {
            // ... (Validation remains the same) ...
            const importCols = parseInt(importSheetColsInput.value); const importRows = parseInt(importSheetRowsInput.value); const importFrameW = parseInt(importSheetWidthInput.value); const importFrameH = parseInt(importSheetHeightInput.value); if (isNaN(importCols) || isNaN(importRows) || isNaN(importFrameW) || isNaN(importFrameH) || importCols < 1 || importRows < 1 || importFrameW < 1 || importFrameH < 1) { showMessage("Invalid dimensions.", 4000); return; } if (!sourceSpriteSheetImage || !sourceSpriteSheetImage.complete) { showMessage("Error: Source image missing.", 4000); return; } if (importCols * importFrameW > sourceSpriteSheetImage.width + 5 || importRows * importFrameH > sourceSpriteSheetImage.height + 5) { if (!confirm(`Warning: Dimensions might exceed image size. Continue?`)) { return; } }

            console.log(`Loading: ${importCols}x${importRows} frames, ${importFrameW}x${importFrameH}px.`);
            showMessage("Processing sheet...", 10000);

            gridColsInput.value = importCols; gridRowsInput.value = importRows;
            frameWidthInput.value = importFrameW; frameHeightInput.value = importFrameH;
            handleSizeChange(); // Update internal state

            placedImages = []; nextImageId = 0; selectedFrameId = null;

            const promises = [];
            // ... (Promise creation loop remains the same) ...
            for (let r = 0; r < importRows; r++) { for (let c = 0; c < importCols; c++) { const sx = c * importFrameW; const sy = r * importFrameH; const framePromise = new Promise((resolve, reject) => { const frameCanvas = document.createElement('canvas'); frameCanvas.width = importFrameW; frameCanvas.height = importFrameH; const frameCtx = frameCanvas.getContext('2d'); try { frameCtx.drawImage(sourceSpriteSheetImage, sx, sy, importFrameW, importFrameH, 0, 0, importFrameW, importFrameH); const frameImg = new Image(); frameImg.onload = () => resolve({ img: frameImg, row: r, col: c }); frameImg.onerror = (err) => { console.error(`Err load frame [${r}, ${c}]`, err); reject(`Failed load ${r}-${c}`); }; frameImg.src = frameCanvas.toDataURL('image/png'); } catch (e) { console.error(`Err draw frame [${r}, ${c}]`, e); reject(`Failed draw ${r}-${c}`); } }); promises.push(framePromise); } }

             Promise.all(promises)
                .then((loadedFramesData) => {
                    placedImages = loadedFramesData.map(data => ({ img: data.img, row: data.row, col: data.col, id: nextImageId++ }));
                    console.log("Frames processed.");
                    redrawCanvas(); // Redraw main canvas
                    startAnimation(); // Start animation with new frames
                    showMessage(`Sheet loaded! ${loadedFramesData.length} frames.`, 4000);
                })
                .catch((error) => { console.error("Error processing:", error); showMessage(`Error loading: ${error}.`, 5000); redrawCanvas(); startAnimation(); /* Still try to animate what loaded */ })
                .finally(() => { handleCancelImportSheet(); });
        }


        // --- Save Handler ---
        function handleSaveClick() { /* ... (no changes needed) ... */
             console.log("Save click."); if (placedImages.length === 0) { showMessage("Nothing to save."); return; } let desiredFilename = prompt("Enter filename:", "spritesheet.png"); if (desiredFilename === null) { showMessage("Save cancelled."); return; } desiredFilename = desiredFilename.trim() || "spritesheet.png"; if (!desiredFilename.toLowerCase().endsWith('.png')) desiredFilename += '.png'; const tempCanvas = document.createElement('canvas'); try { const requiredWidth = gridCols * frameWidth; const requiredHeight = gridRows * frameHeight; if (requiredWidth <= 0 || requiredHeight <= 0) { showMessage("Invalid dimensions."); return; } tempCanvas.width = requiredWidth; tempCanvas.height = requiredHeight; const tempCtx = tempCanvas.getContext('2d'); let imagesDrawn = 0; placedImages.forEach(item => { if (item && item.img && item.img.complete) { try { tempCtx.drawImage(item.img, item.col * frameWidth, item.row * frameHeight, frameWidth, frameHeight); imagesDrawn++; } catch (e) { console.error(`Err draw ID ${item.id}`, e); } } else { console.warn(`Skip unload ID ${item?.id}`); } }); if (imagesDrawn === 0 && placedImages.length > 0) { showMessage("Could not draw images.", 5000); return; } const dataURL = tempCanvas.toDataURL('image/png'); const link = document.createElement('a'); link.href = dataURL; link.download = desiredFilename; document.body.appendChild(link); link.click(); document.body.removeChild(link); showMessage(`Saved as ${desiredFilename}! (${imagesDrawn} frames)`); } catch (e) { console.error("Error saving:", e); showMessage("Error saving. See console.", 5000); } }

         // --- Delete Handler ---
         function handleDeleteSelected() {
             if (selectedFrameId === null) { showMessage("No frame selected."); return; }
             const index = placedImages.findIndex(item => item.id === selectedFrameId);
             if (index !== -1) { const deletedItem = placedImages.splice(index, 1)[0]; console.log(`Deleted ID ${selectedFrameId}`); selectedFrameId = null; redrawCanvas(); startAnimation(); /* Update animation */ showMessage("Frame deleted."); }
             else { showMessage("Selected frame not found."); selectedFrameId = null; updateSelectionHighlight(); }
         }


        // --- Drag and Drop & Selection Logic ---
        function getMousePos(canvas, evt) { /* ... (no changes needed) ... */ const rect = canvas.getBoundingClientRect(); const clientX = evt.clientX ?? evt.touches?.[0]?.clientX; const clientY = evt.clientY ?? evt.touches?.[0]?.clientY; if (typeof clientX !== 'number' || typeof clientY !== 'number') { console.warn("No mouse pos."); return null; } return { x: clientX - rect.left, y: clientY - rect.top }; }
        function handleMouseDown(event) {
             const pos = getMousePos(canvas, event); if (!pos) return; if (event.type === 'touchstart') event.preventDefault(); startX = pos.x; startY = pos.y; dragStartX = event.clientX ?? event.touches?.[0]?.clientX; dragStartY = event.clientY ?? event.touches?.[0]?.clientY; dragMoved = false;
             const clickedCol = Math.floor(pos.x / frameWidth); const clickedRow = Math.floor(pos.y / frameHeight);
             if (clickedCol < 0 || clickedCol >= gridCols || clickedRow < 0 || clickedRow >= gridRows || frameWidth <= 0 || frameHeight <= 0) { if (selectedFrameId !== null) { selectedFrameId = null; redrawCanvas(); startAnimation(); /* Update animation */ } draggedImage = null; isDragging = false; return; }
             const clickedImage = placedImages.find(item => item.row === clickedRow && item.col === clickedCol);
             if (clickedImage) {
                 draggedImage = clickedImage; isDragging = false; offsetX = pos.x - (draggedImage.col * frameWidth); offsetY = pos.y - (draggedImage.row * frameHeight); canvas.style.cursor = 'grab';
                 if (selectedFrameId !== clickedImage.id) {
                     selectedFrameId = clickedImage.id;
                     redrawCanvas(); // Update visual selection
                     startAnimation(); // Update animation based on new selection
                 }
             } else {
                 draggedImage = null; isDragging = false; canvas.style.cursor = 'default';
                 if (selectedFrameId !== null) {
                     selectedFrameId = null; // Deselect if clicking empty cell
                     redrawCanvas();
                     startAnimation(); // Update animation
                 }
             }
        }
        function handleMouseMove(event) { /* ... (logic for starting drag remains same) ... */
            if (!draggedImage) return; const currentX = event.clientX ?? event.touches?.[0]?.clientX; const currentY = event.clientY ?? event.touches?.[0]?.clientY; if (typeof currentX !== 'number' || typeof currentY !== 'number') return; const moveThreshold = 5;
            if (!isDragging && (Math.abs(currentX - dragStartX) > moveThreshold || Math.abs(currentY - dragStartY) > moveThreshold)) {
                isDragging = true; dragMoved = true;
                if (selectedFrameId === draggedImage.id) { // Only deselect if the dragged item was selected
                    selectedFrameId = null;
                    startAnimation(); // Update animation as selection is cleared
                }
                canvas.style.cursor = 'grabbing'; console.log("Drag start ID:", draggedImage.id);
            }
            if (isDragging) { if (event.type === 'touchmove') event.preventDefault(); const pos = getMousePos(canvas, event); if (!pos) return; startX = pos.x; startY = pos.y; redrawCanvas(); }
        }
        function handleMouseUp(event) {
            const wasDragging = isDragging; const currentlyDragged = draggedImage;
            if (isDragging) {
                isDragging = false; canvas.style.cursor = 'default';
                let requiresAnimationUpdate = false; // Flag if drop changes animation sequence
                const pos = getMousePos(canvas, event);
                if (pos && frameWidth > 0 && frameHeight > 0 && currentlyDragged) {
                    const targetCol = Math.floor(pos.x / frameWidth); const targetRow = Math.floor(pos.y / frameHeight);
                    if (targetCol >= 0 && targetCol < gridCols && targetRow >= 0 && targetRow < gridRows) {
                        const existingImage = placedImages.find(item => item.row === targetRow && item.col === targetCol && item.id !== currentlyDragged.id);
                        if (!existingImage) {
                            // Check if the row changed (affects row-based animation)
                            if (currentlyDragged.row !== targetRow) {
                                requiresAnimationUpdate = true;
                            }
                            currentlyDragged.row = targetRow; currentlyDragged.col = targetCol;
                            console.log(`Drop ID ${currentlyDragged.id} at [${targetRow}, ${targetCol}]`);
                        } else { showMessage("Target occupied."); console.log(`Drop fail ID ${currentlyDragged.id}: target [${targetRow}, ${targetCol}] occupied`); }
                    } else { showMessage("Dropped outside grid."); console.log(`Drop fail ID ${currentlyDragged.id}: outside grid`); }
                } else { console.warn("Could not get drop location."); }
                draggedImage = null;
                redrawCanvas();
                if (requiresAnimationUpdate) { startAnimation(); } // Update animation only if row changed
            } else if (currentlyDragged && !dragMoved) { console.log(`Click ID ${currentlyDragged.id}. Sel state: ${selectedFrameId}`); canvas.style.cursor = 'grab'; }
            if (!isDragging) { draggedImage = null; } dragMoved = false;
        }
        function handleMouseLeave(event) { /* ... (no changes needed) ... */ if (isDragging) { isDragging = false; const previouslyDragged = draggedImage; draggedImage = null; canvas.style.cursor = 'default'; redrawCanvas(); showMessage("Drag cancelled."); console.log(`Drag cancel ID ${previouslyDragged?.id}`); } else if (canvas.style.cursor === 'grab') { canvas.style.cursor = 'default'; } }


        // --- Animation Functions ---
        function stopAnimation() {
            if (animationIntervalId !== null) {
                clearInterval(animationIntervalId);
                animationIntervalId = null;
            }
             // Optionally clear the preview canvas when stopped
             // animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);
        }

        function runAnimationLoop() {
            if (framesToAnimate.length === 0) {
                // Clear preview if no frames to animate
                animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);
                return;
            }

            // Get the current frame data object
            const currentFrameData = framesToAnimate[currentAnimationFrameIndex];

            // Clear previous frame
            animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);

            // Draw current frame if image is loaded
            if (currentFrameData && currentFrameData.img && currentFrameData.img.complete) {
                try {
                    // Draw image centered if canvas is larger (though they should match)
                    const drawW = animationPreviewCanvas.width;
                    const drawH = animationPreviewCanvas.height;
                    animationPreviewCtx.drawImage(currentFrameData.img, 0, 0, drawW, drawH);
                } catch (e) {
                    console.error("Error drawing animation frame:", e);
                    // Optionally draw an error indicator
                    animationPreviewCtx.fillStyle = 'red';
                    animationPreviewCtx.fillText('!', drawW / 2, drawH / 2);
                }
            } else {
                 // Optionally draw a loading indicator
                 animationPreviewCtx.fillStyle = '#9ca3af';
                 animationPreviewCtx.textAlign = 'center';
                 animationPreviewCtx.textBaseline = 'middle';
                 animationPreviewCtx.fillText('...', animationPreviewCanvas.width / 2, animationPreviewCanvas.height / 2);
            }

            // Move to next frame index
            currentAnimationFrameIndex = (currentAnimationFrameIndex + 1) % framesToAnimate.length;
        }

        function startAnimation() {
            stopAnimation(); // Clear any existing animation interval

            const selectedItem = selectedFrameId !== null ? placedImages.find(item => item.id === selectedFrameId) : null;

            if (selectedItem) {
                // Animate frames in the selected row
                framesToAnimate = placedImages
                    .filter(item => item.row === selectedItem.row)
                    .sort((a, b) => a.col - b.col); // Sort by column
            } else {
                // Animate all frames, sorted by row, then column
                framesToAnimate = [...placedImages] // Create a copy before sorting
                    .sort((a, b) => a.row - b.row || a.col - b.col);
            }

            currentAnimationFrameIndex = 0; // Reset frame index

            if (framesToAnimate.length > 0 && animationFps > 0) {
                const intervalDelay = 1000 / animationFps;
                animationIntervalId = setInterval(runAnimationLoop, intervalDelay);
                console.log(`Animation started with ${framesToAnimate.length} frames at ${animationFps} FPS.`);
            } else {
                 // Clear preview if no frames or FPS is zero
                 animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);
                 console.log("Animation not started: No frames or FPS is zero.");
            }
        }


        // --- Event Listeners ---
        gridColsInput.addEventListener('change', handleSizeChange);
        gridRowsInput.addEventListener('change', handleSizeChange);
        frameWidthInput.addEventListener('change', handleSizeChange);
        frameHeightInput.addEventListener('change', handleSizeChange);
        importFramesButton.addEventListener('click', handleImportFramesClick);
        importSheetButton.addEventListener('click', handleImportSheetClick);
        frameFileInput.addEventListener('change', handleFrameFileSelect);
        sheetFileInput.addEventListener('change', handleSheetFileSelect);
        saveButton.addEventListener('click', handleSaveClick);
        deleteFrameButton.addEventListener('click', handleDeleteSelected);

        // Modal Listeners
        cancelImportSheetButton.addEventListener('click', handleCancelImportSheet);
        loadSheetButton.addEventListener('click', handleLoadSpriteSheet);

        // Canvas Listeners
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseLeave);
        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleMouseUp);
        canvas.addEventListener('touchcancel', handleMouseLeave);


        // --- Initial Setup ---
        createSelectionHighlight(); // Create the highlight div initially
        redrawCanvas(); // Draw initial grid and resize preview canvas
        startAnimation(); // Start animation initially (likely with no frames)
        console.log("Sprite Sheet Editor Initialized.");

    </script>

</body>
</html>
