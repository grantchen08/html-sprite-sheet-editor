<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
        canvas#sprite-canvas { /* Target main canvas */
            border: 1px solid #d1d5db; /* gray-300 */
            cursor: default; /* Default cursor, change on hover/drag */
            touch-action: none; /* Prevent default touch actions like scrolling */
            background-color: #f9fafb; /* Add a light background */
            display: block; /* Prevent extra space */
        }

        .control-panel label,
        .modal-content label,
        #animation-preview-container label { /* Apply label style */
            @apply block text-sm font-medium text-gray-700 mb-1;
        }

        /* --- Custom CSS Input Styles (Applied via .gui-input class) --- */
        .gui-input {
            display: block;
            width: 100%;
            padding: 0.5rem; /* p-2 */
            font-size: 0.875rem; /* text-sm */
            color: #1f2937; /* gray-800 */
            background-color: #ffffff; /* bg-white */
            border: 1px solid #9ca3af; /* gray-400 */
             /* Classic bevel effect borders - slightly different for inset feel */
            border-top-color: #6b7280; /* gray-500 */
            border-left-color: #6b7280; /* gray-500 */
            border-bottom-color: #e5e7eb; /* gray-200 */
            border-right-color: #e5e7eb; /* gray-200 */
            border-radius: 0.25rem; /* rounded */
            transition: border-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            /* Spinners restored (no hiding rules) */
        }


        /* Custom focus style for inputs */
         .gui-input:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            /* Replicate Tailwind focus ring using box-shadow */
            box-shadow: 0 0 0 2px #ffffff, 0 0 0 4px #6366f1; /* ring-2 ring-indigo-500 ring-offset-2 */
            border-color: #6366f1; /* focus:border-indigo-500 */
         }
        /* --- End of Custom Input Styles --- */

        /* --- Custom CSS Button Styles --- */
        .gui-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem; /* Equivalent to px-4 py-2 */
            font-size: 0.875rem; /* Equivalent to text-sm */
            font-weight: 500; /* Equivalent to font-medium */
            color: #1f2937; /* gray-800 */
            background-color: #f3f4f6; /* gray-100 - Base solid color */
            border: 1px solid #9ca3af; /* gray-400 */
            /* Classic bevel effect borders */
            border-top-color: #e5e7eb; /* gray-200 */
            border-left-color: #e5e7eb; /* gray-200 */
            border-bottom-color: #6b7280; /* gray-500 */
            border-right-color: #6b7280; /* gray-500 */
            border-radius: 0.25rem; /* Equivalent to rounded */
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.1s ease-in-out, border-style 0.1s ease-in-out;
            /* Focus styles (Tailwind classes for consistency) */
            @apply focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2;
        }

        .gui-button:hover {
            background-color: #e5e7eb; /* gray-200 */
        }

        .gui-button:active {
            background-color: #d1d5db; /* gray-300 */
            border-style: inset; /* Inset border on click */
        }

        .gui-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Ensure icons align vertically */
         .gui-button .lucide {
             vertical-align: middle;
             margin-right: 0.3em; /* Slightly less margin */
         }
         /* Keep margin for modal secondary button */
         .modal-content button#cancel-import-sheet,
         .modal-content button#cancel-downsample-button,
         .modal-content button#cancel-save-button { /* Apply to all cancel buttons */
             margin-left: 0.75rem; /* ml-3 */
         }
         /* --- End of Custom Button Styles --- */

        /* Style for the message box */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 8px; /* More rounded */
            display: none; /* Hidden by default */
            z-index: 1050; /* Ensure it's above modal overlay */
            max-width: 90%;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Below message box, above content */
        }
        .modal-content {
            background-color: white;
            padding: 2rem; /* More padding */
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw; /* Limit width */
            max-height: 90vh; /* Limit height */
            overflow-y: auto; /* Allow scrolling if content overflows */
            width: 500px; /* Default width */
        }
        /* Reduce width for simpler modals */
        #downsample-modal .modal-content,
        #save-modal .modal-content { /* Apply to downsample and save modals */
            width: 400px;
        }
        .modal-content h2 {
             @apply text-xl font-semibold text-gray-900 mb-4;
        }
        /* Style for the preview canvas */
        #sprite-sheet-preview-canvas {
            max-width: 100%;
            border: 1px solid #d1d5db; /* gray-300 */
            margin-bottom: 1rem;
            display: block; /* Ensure it behaves like a block element */
            margin-left: auto; /* Center preview */
            margin-right: auto;
            background-color: #f8f8f8; /* Light background for canvas */
            position: relative; /* Needed for absolute positioning of overlay */
        }
        /* Style for margin overlay on preview */
        #import-sheet-modal .margin-overlay {
            position: absolute;
            background-color: rgba(100, 100, 100, 0.3); /* Semi-transparent gray */
            pointer-events: none; /* Don't interfere with clicks */
        }


        /* Selection Highlight - Style removed as it's drawn on canvas now */
        /* .selected-frame-highlight { ... } */


        /* Animation Preview Styles */
        #animation-preview-container {
            /* Removed top border, now part of the side-by-side layout */
        }
        #animation-preview-canvas {
            border: 1px solid #d1d5db; /* gray-300 */
            background-color: #f0f0f0; /* Slightly different background */
            display: block; /* Prevent extra space below */
            margin-left: auto; /* Center */
            margin-right: auto;
            margin-top: 0.5rem; /* Space below label */
            /* Display size will be set by JS */
        }

    </style>
    <style>
      /* Lucide Icon Font Setup */
      @font-face {
        font-family: 'LucideIcons';
        src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
      }
      .lucide {
        font-family: 'LucideIcons';
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-rendering: auto;
        line-height: 1;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        display: inline-block; /* Ensure proper alignment */
      }
      /* Map icon names to their Unicode characters */
      .lucide-upload::before { content: "\ef1b"; } /* upload icon */
      .lucide-save::before { content: "\ee9f"; }    /* save icon */
      .lucide-file-image::before { content: "\edc8"; } /* file-image icon */
      .lucide-trash-2::before { content: "\ef0b"; } /* trash-2 icon */
      .lucide-filter::before { content: "\edc1"; } /* filter icon */

    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="container mx-auto bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-semibold text-gray-900 mb-6 text-center">Sprite Sheet Editor</h1>

        <div class="control-panel grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 items-end">
            <div>
                <label for="grid-cols">Grid Columns:</label>
                <input type="number" id="grid-cols" class="gui-input" value="4" min="1">
            </div>
            <div>
                <label for="grid-rows">Grid Rows:</label>
                <input type="number" id="grid-rows" class="gui-input" value="4" min="1">
            </div>
            <div>
                <label for="frame-width">Frame Width (px):</label>
                <input type="number" id="frame-width" class="gui-input" value="64" min="1">
            </div>
            <div>
                <label for="frame-height">Frame Height (px):</label>
                <input type="number" id="frame-height" class="gui-input" value="64" min="1">
            </div>
            <div class="col-span-2 md:col-span-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mt-4">
                 <button id="import-frames-button" class="gui-button">
                   <span class="lucide lucide-upload"></span>Import Frames
                 </button>
                 <button id="import-sheet-button" class="gui-button">
                   <span class="lucide lucide-file-image"></span>Import Sheet
                 </button>
                 <button id="downsample-button" class="gui-button">
                   <span class="lucide lucide-filter"></span>Downsample
                 </button>
                 <button id="delete-frame-button" class="gui-button" disabled>
                   <span class="lucide lucide-trash-2"></span>Delete Frame(s) </button>
                <button id="save-button" class="gui-button"> <span class="lucide lucide-save"></span>Save Sprite Sheet
                </button>
            </div>
        </div>

        <input type="file" id="frame-file-input" multiple accept="image/*" class="hidden">
        <input type="file" id="sheet-file-input" accept="image/*" class="hidden">

        <div class="flex flex-col md:flex-row gap-6 mt-6">

            <div id="canvas-container-wrapper" class="flex-grow md:w-3/4 border border-gray-200 rounded-md p-3 bg-gray-50">
                 <p class="text-sm font-medium text-gray-700 mb-2 text-center">Sprite Sheet Canvas</p>
                 <div id="canvas-container" class="relative w-full overflow-auto border border-gray-300 rounded-md bg-gray-50">
                    <canvas id="sprite-canvas"></canvas>
                    </div>
            </div>

            <div id="animation-preview-container" class="md:w-1/4 border border-gray-200 rounded-md p-3 bg-gray-50 flex flex-col items-center">
                <label for="animation-preview-canvas" class="text-center block font-medium">Animation Preview</label>
                <canvas id="animation-preview-canvas" class="mt-2"></canvas>
                 <div class="mt-4 text-center">
                    <label for="animation-fps" class="text-sm text-gray-600 mr-2">FPS:</label>
                    <input type="number" id="animation-fps" class="gui-input inline-block w-16 text-center" value="10" min="1" max="60">
                 </div>
            </div>

        </div>

        <div id="message-box"></div>

        <div id="import-sheet-modal" class="modal-overlay hidden">
             <div class="modal-content">
                 <h2>Import Sprite Sheet</h2>
                 <div class="relative mb-4">
                    <canvas id="sprite-sheet-preview-canvas"></canvas>
                    <div id="margin-overlay-top" class="margin-overlay"></div>
                    <div id="margin-overlay-bottom" class="margin-overlay"></div>
                    <div id="margin-overlay-left" class="margin-overlay"></div>
                    <div id="margin-overlay-right" class="margin-overlay"></div>
                 </div>
                 <p class="text-sm text-gray-600 mb-4">Define grid/frame size for the area inside the margins.</p>
                 <div class="grid grid-cols-2 gap-x-4 gap-y-3 mb-4">
                      <div>
                          <label for="import-sheet-cols">Grid Columns:</label>
                          <input type="number" id="import-sheet-cols" class="gui-input" value="4" min="1" step="1">
                      </div>
                      <div>
                          <label for="import-sheet-rows">Grid Rows:</label>
                          <input type="number" id="import-sheet-rows" class="gui-input" value="4" min="1" step="1">
                      </div>
                      <div>
                          <label for="import-sheet-width">Frame Width (px):</label>
                          <input type="number" id="import-sheet-width" class="gui-input" value="64" min="1" step="1">
                      </div>
                      <div>
                          <label for="import-sheet-height">Frame Height (px):</label>
                          <input type="number" id="import-sheet-height" class="gui-input" value="64" min="1" step="1">
                      </div>
                 </div>
                 <p class="text-sm font-medium text-gray-700 mb-1">Margins (px):</p>
                 <div class="grid grid-cols-4 gap-x-4 gap-y-3 mb-4">
                   <div>
                       <label for="import-margin-left">Left:</label>
                       <input type="number" id="import-margin-left" class="gui-input" value="0" min="0" step="1">
                   </div>
                   <div>
                       <label for="import-margin-top">Top:</label>
                       <input type="number" id="import-margin-top" class="gui-input" value="0" min="0" step="1">
                   </div>
                   <div>
                       <label for="import-margin-right">Right:</label>
                       <input type="number" id="import-margin-right" class="gui-input" value="0" min="0" step="1">
                   </div>
                   <div>
                       <label for="import-margin-bottom">Bottom:</label>
                       <input type="number" id="import-margin-bottom" class="gui-input" value="0" min="0" step="1">
                   </div>
                 </div>
                 <p class="text-sm font-medium text-gray-700 mb-1">Target Frame Size (Optional):</p>
                 <p class="text-xs text-gray-500 mb-2">Leave blank to use original size. Frames will be resampled.</p>
                 <div class="grid grid-cols-2 gap-x-4 gap-y-3">
                   <div>
                       <label for="import-target-width">Target Width (px):</label>
                       <input type="number" id="import-target-width" class="gui-input" placeholder="Original" min="1" step="1">
                   </div>
                   <div>
                       <label for="import-target-height">Target Height (px):</label>
                       <input type="number" id="import-target-height" class="gui-input" placeholder="Original" min="1" step="1">
                   </div>
                 </div>
                 <div class="mt-6 text-right">
                      <button id="cancel-import-sheet" class="gui-button">Cancel</button>
                      <button id="load-sheet-button" class="gui-button">Load Sprite Sheet</button>
                 </div>
             </div>
        </div>

        <div id="downsample-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>Downsample Frames</h2>
                <p class="text-sm text-gray-600 mb-4">Keep 1 out of every N frames in each row. Enter the value for N below (minimum 2).</p>
                <div>
                    <label for="downsample-ratio">Keep 1 / N frames (N):</label>
                    <input type="number" id="downsample-ratio" class="gui-input" value="2" min="2" step="1">
                </div>
                 <div class="mt-6 text-right">
                      <button id="cancel-downsample-button" class="gui-button">Cancel</button>
                      <button id="apply-downsample-button" class="gui-button">Apply Downsampling</button>
                 </div>
            </div>
       </div>

        <div id="save-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>Save Options</h2>
                <div class="mb-4">
                    <label for="save-filename">Base Filename:</label>
                    <input type="text" id="save-filename" class="gui-input" value="spritesheet">
                    <p class="text-xs text-gray-500 mt-1">`.png` extension will be added. If saving by row, `_rowN` will also be added.</p>
                </div>
                <div class="flex items-center mb-6">
                     <input id="save-by-row-checkbox" name="save-by-row" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                     <label for="save-by-row-checkbox" class="ml-2 block text-sm text-gray-900">Save each row as a separate file</label>
                </div>
                 <div class="mt-6 text-right">
                      <button id="cancel-save-button" class="gui-button">Cancel</button>
                      <button id="confirm-save-button" class="gui-button">Save</button>
                 </div>
            </div>
       </div>


    </div> <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('sprite-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        const gridColsInput = document.getElementById('grid-cols');
        const gridRowsInput = document.getElementById('grid-rows');
        const frameWidthInput = document.getElementById('frame-width');
        const frameHeightInput = document.getElementById('frame-height');
        const importFramesButton = document.getElementById('import-frames-button');
        const importSheetButton = document.getElementById('import-sheet-button');
        const saveButton = document.getElementById('save-button');
        const deleteFrameButton = document.getElementById('delete-frame-button');
        const frameFileInput = document.getElementById('frame-file-input');
        const sheetFileInput = document.getElementById('sheet-file-input');
        const messageBox = document.getElementById('message-box');
        // Selection highlight div removed

        // Import Sheet Modal elements
        const importSheetModal = document.getElementById('import-sheet-modal');
        const modalPreviewCanvas = document.getElementById('sprite-sheet-preview-canvas');
        const modalPreviewCtx = modalPreviewCanvas.getContext('2d');
        let importSheetColsInput = document.getElementById('import-sheet-cols');
        let importSheetRowsInput = document.getElementById('import-sheet-rows');
        let importSheetWidthInput = document.getElementById('import-sheet-width');
        let importSheetHeightInput = document.getElementById('import-sheet-height');
        // Margin Inputs
        let importMarginLeftInput = document.getElementById('import-margin-left');
        let importMarginTopInput = document.getElementById('import-margin-top');
        let importMarginRightInput = document.getElementById('import-margin-right');
        let importMarginBottomInput = document.getElementById('import-margin-bottom');
        // NEW: Target Size Inputs
        let importTargetWidthInput = document.getElementById('import-target-width');
        let importTargetHeightInput = document.getElementById('import-target-height');
        // Margin Overlays
        const marginOverlayTop = document.getElementById('margin-overlay-top');
        const marginOverlayBottom = document.getElementById('margin-overlay-bottom');
        const marginOverlayLeft = document.getElementById('margin-overlay-left');
        const marginOverlayRight = document.getElementById('margin-overlay-right');
        // ---
        const cancelImportSheetButton = document.getElementById('cancel-import-sheet');
        const loadSheetButton = document.getElementById('load-sheet-button');

        // Animation Preview elements
        const animationPreviewCanvas = document.getElementById('animation-preview-canvas');
        const animationPreviewCtx = animationPreviewCanvas.getContext('2d');
        const animationFpsInput = document.getElementById('animation-fps');

        // Downsample Elements
        const downsampleButton = document.getElementById('downsample-button');
        const downsampleModal = document.getElementById('downsample-modal');
        const downsampleRatioInput = document.getElementById('downsample-ratio');
        const applyDownsampleButton = document.getElementById('apply-downsample-button');
        const cancelDownsampleButton = document.getElementById('cancel-downsample-button');

        // Save Modal Elements
        const saveModal = document.getElementById('save-modal');
        const saveFilenameInput = document.getElementById('save-filename');
        const saveByRowCheckbox = document.getElementById('save-by-row-checkbox');
        const confirmSaveButton = document.getElementById('confirm-save-button');
        const cancelSaveButton = document.getElementById('cancel-save-button');


        // --- State Variables ---
        let gridCols = parseInt(gridColsInput.value);
        let gridRows = parseInt(gridRowsInput.value);
        let frameWidth = parseInt(frameWidthInput.value);
        let frameHeight = parseInt(frameHeightInput.value);
        let placedImages = []; // Array to store { img, row, col, id } objects
        let nextImageId = 0;
        // let selectedFrameId = null; // Replaced by Set
        let selectedFrameIds = new Set(); // Use a Set for multiple selections
        let lastSelectedFrameId = null; // Track the last clicked frame for Shift+Click
        let sourceSpriteSheetImage = null;

        // Modal Preview canvas state
        let modalPreviewScaleFactor = 1;
        let modalPreviewOffsetX = 0;
        let modalPreviewOffsetY = 0;
        let modalPreviewDrawnWidth = 0;
        let modalPreviewDrawnHeight = 0;
        let isUpdatingModalInputs = false;

        // Animation state
        let animationIntervalId = null;
        let currentAnimationFrameIndex = 0;
        let animationFps = parseInt(animationFpsInput.value);
        let framesToAnimate = [];

        // Drag and Drop State
        let isDragging = false;
        let dragMoved = false;
        let draggedImage = null;
        let dragStartCanvasX, dragStartCanvasY;
        let dragStartClientX, dragStartClientY;
        let dragOffsetX, dragOffsetY;


        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            if (messageBox.timeoutId) clearTimeout(messageBox.timeoutId);
            messageBox.timeoutId = setTimeout(() => {
                messageBox.style.display = 'none';
                messageBox.timeoutId = null;
            }, duration);
        }

        function triggerDownload(dataURL, filename) {
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }


        // --- Selection Highlight (Now drawn on canvas) ---
        function drawSelectionHighlights() {
             if (selectedFrameIds.size === 0 || frameWidth <= 0 || frameHeight <= 0) {
                 return;
             }

             ctx.strokeStyle = '#4f46e5'; // Indigo-600
             ctx.lineWidth = 2;
             ctx.fillStyle = 'rgba(79, 70, 229, 0.1)'; // Semi-transparent fill

             selectedFrameIds.forEach(id => {
                 const selectedItem = placedImages.find(item => item.id === id);
                 if (selectedItem) {
                     const x = selectedItem.col * frameWidth;
                     const y = selectedItem.row * frameHeight;
                     // Draw slightly inset rectangle for highlight
                     ctx.strokeRect(x + 1, y + 1, frameWidth - 2, frameHeight - 2);
                     // Optional: Add a subtle fill
                     ctx.fillRect(x + 1, y + 1, frameWidth - 2, frameHeight - 2);

                     // Optional: Draw a white inner border for better contrast if needed
                     // ctx.strokeStyle = 'white';
                     // ctx.lineWidth = 1;
                     // ctx.strokeRect(x + 3, y + 3, frameWidth - 6, frameHeight - 6);
                 }
             });
             // Reset stroke/fill style if needed elsewhere
             ctx.lineWidth = 1;
             ctx.strokeStyle = '#e5e7eb'; // Reset to grid color
        }

        function updateDeleteButtonState() {
            deleteFrameButton.disabled = selectedFrameIds.size === 0;
        }


        // --- Canvas Drawing ---
        function drawGrid() {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
                for (let i = 0; i <= gridCols; i++) {
                    const x = i * frameWidth; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
                }
                for (let i = 0; i <= gridRows; i++) {
                    const y = i * frameHeight; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
                }
            } catch (e) { console.error("Error drawing grid:", e); showMessage("Error rendering grid.", 5000); }
        }

        function drawImages() {
            try {
                // Set default cursor unless dragging
                if (!isDragging) canvas.style.cursor = 'default';

                placedImages.forEach(item => {
                    const drawX = item.col * frameWidth; const drawY = item.row * frameHeight;
                    if (item?.img?.complete) {
                        // Don't draw the original image if it's being dragged
                        if (!isDragging || item.id !== draggedImage?.id) {
                            ctx.drawImage(item.img, drawX, drawY, frameWidth, frameHeight);
                        }
                    } else if (item?.img) { // Image exists but not loaded
                        ctx.fillStyle = '#f3f4f6'; ctx.fillRect(drawX + 2, drawY + 2, frameWidth - 4, frameHeight - 4);
                        ctx.fillStyle = '#9ca3af'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '12px Inter';
                        ctx.fillText('Loading...', drawX + frameWidth / 2, drawY + frameHeight / 2);
                    }
                });
                // Draw the dragged image semi-transparently at the mouse position
                if (isDragging && draggedImage?.img?.complete) {
                    ctx.globalAlpha = 0.6;
                    ctx.drawImage(draggedImage.img, dragStartCanvasX - dragOffsetX, dragStartCanvasY - dragOffsetY, frameWidth, frameHeight);
                    ctx.globalAlpha = 1.0;
                    canvas.style.cursor = 'grabbing';
                }
            } catch (e) {
                console.error("Error drawing images:", e); showMessage("Error rendering images.", 5000);
                if (isDragging) { isDragging = false; draggedImage = null; canvas.style.cursor = 'default'; }
            }
        }

        function redrawCanvas() {
            try {
                const newCanvasWidth = gridCols * frameWidth;
                const newCanvasHeight = gridRows * frameHeight;

                if (newCanvasWidth <= 0 || newCanvasHeight <= 0 || !Number.isFinite(newCanvasWidth) || !Number.isFinite(newCanvasHeight)) {
                    console.warn("Skipping redraw: invalid dimensions", newCanvasWidth, newCanvasHeight);
                    if (canvas.width > 0 && canvas.height > 0) ctx.clearRect(0, 0, canvas.width, canvas.height);
                    animationPreviewCanvas.width = 1; animationPreviewCanvas.height = 1;
                    animationPreviewCanvas.style.width = `1px`; animationPreviewCanvas.style.height = `1px`;
                    animationPreviewCtx.clearRect(0, 0, 1, 1); stopAnimation(); return;
                }

                if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {
                    canvas.width = newCanvasWidth; canvas.height = newCanvasHeight;
                }

                const currentPreviewWidth = frameWidth > 0 ? frameWidth : 1;
                const currentPreviewHeight = frameHeight > 0 ? frameHeight : 1;
                if (animationPreviewCanvas.width !== currentPreviewWidth || animationPreviewCanvas.height !== currentPreviewHeight) {
                   animationPreviewCanvas.width = currentPreviewWidth;
                   animationPreviewCanvas.height = currentPreviewHeight;
                   animationPreviewCanvas.style.width = `${currentPreviewWidth}px`;
                   animationPreviewCanvas.style.height = `${currentPreviewHeight}px`;
                }

                drawGrid();
                drawImages();
                drawSelectionHighlights(); // Draw highlights after images
                updateDeleteButtonState(); // Update button based on selection

            } catch (e) { console.error("Error in redrawCanvas:", e); showMessage("Error updating canvas.", 5000); }
        }

        // --- Event Handlers ---
        function handleSizeChange() {
            const newCols = parseInt(gridColsInput.value); const newRows = parseInt(gridRowsInput.value);
            const newFrameW = parseInt(frameWidthInput.value); const newFrameH = parseInt(frameHeightInput.value);
            if (isNaN(newCols) || isNaN(newRows) || isNaN(newFrameW) || isNaN(newFrameH) || newCols < 1 || newRows < 1 || newFrameW < 1 || newFrameH < 1) {
                showMessage("Invalid size: values must be positive numbers.");
                gridColsInput.value = gridCols; gridRowsInput.value = gridRows; frameWidthInput.value = frameWidth; frameHeightInput.value = frameHeight; return;
            }
            // Store previous values for potential resizing check
            const oldFrameWidth = frameWidth;
            const oldFrameHeight = frameHeight;

            gridCols = newCols; gridRows = newRows; frameWidth = newFrameW; frameHeight = newFrameH;
            // const oldSelectedId = selectedFrameId; // No longer single ID

            // Filter out images outside the new grid bounds
            placedImages = placedImages.filter(item => item.row < gridRows && item.col < gridCols);

            // Remove IDs from selection if they are no longer in placedImages
            const currentPlacedIds = new Set(placedImages.map(item => item.id));
            selectedFrameIds.forEach(id => {
                if (!currentPlacedIds.has(id)) {
                    selectedFrameIds.delete(id);
                    if (lastSelectedFrameId === id) {
                        lastSelectedFrameId = null; // Reset last selected if it was removed
                    }
                }
            });


            // --- START: Resize existing frames if frame dimensions changed ---
            // Check if frame dimensions actually changed and if there are images
            if ((frameWidth !== oldFrameWidth || frameHeight !== oldFrameHeight) && placedImages.length > 0) {
                console.log(`Frame size changed from ${oldFrameWidth}x${oldFrameHeight} to ${frameWidth}x${frameHeight}. Resizing existing ${placedImages.length} frames.`);
                showMessage("Resizing existing frames...", 5000); // Inform user

                const resizePromises = placedImages.map(item => {
                    return new Promise((resolve, reject) => {
                        // Only resize if the image object exists and is loaded
                        if (!item.img || !item.img.complete || !item.img.naturalWidth || !item.img.naturalHeight) {
                            console.warn(`Skipping resize for frame ID ${item.id}: Image not loaded or invalid.`);
                            resolve(item); // Resolve with the original item if not resizable
                            return;
                        }

                        // Check if this specific image actually needs resizing (it might already be the target size)
                        if (item.img.naturalWidth === frameWidth && item.img.naturalHeight === frameHeight) {
                            resolve(item); // No resize needed for this one
                            return;
                        }

                        const resizeCanvas = document.createElement('canvas');
                        resizeCanvas.width = frameWidth;
                        resizeCanvas.height = frameHeight;
                        const resizeCtx = resizeCanvas.getContext('2d');

                        // Apply high-quality smoothing
                        resizeCtx.imageSmoothingEnabled = true;
                        resizeCtx.imageSmoothingQuality = 'high';

                        try {
                            // Draw the original image onto the resize canvas (resampling happens here)
                            resizeCtx.drawImage(item.img, 0, 0, item.img.naturalWidth, item.img.naturalHeight, 0, 0, frameWidth, frameHeight);

                            // Create a new Image object from the resized canvas data
                            const resizedImg = new Image();
                            resizedImg.onload = () => {
                                // Create a *new* item object with the resized image, keeping other properties
                                resolve({ ...item, img: resizedImg });
                            };
                            resizedImg.onerror = (err) => {
                                console.error(`Error loading resized image data for frame ID ${item.id}:`, err);
                                reject(new Error(`Failed to load resized image for frame ID ${item.id}`));
                            };
                            resizedImg.src = resizeCanvas.toDataURL('image/png');

                        } catch (e) {
                            console.error(`Error resizing frame ID ${item.id}:`, e);
                            reject(new Error(`Failed to resize frame ID ${item.id}`));
                        }
                    });
                });

                // Wait for all resize operations to complete
                Promise.allSettled(resizePromises)
                    .then(results => {
                        const updatedImages = [];
                        let resizeSuccessCount = 0;
                        let resizeFailCount = 0;

                        results.forEach((result, index) => {
                            if (result.status === 'fulfilled') {
                                updatedImages.push(result.value); // Add the (potentially resized) item
                                // Check if resize actually happened for logging purposes
                                if (result.value.img !== placedImages[index].img) {
                                     resizeSuccessCount++;
                                }
                            } else {
                                console.error(`Failed to resize frame ID ${placedImages[index].id}:`, result.reason);
                                updatedImages.push(placedImages[index]); // Keep the original image on failure
                                resizeFailCount++;
                            }
                        });

                        placedImages = updatedImages; // Update the main array

                        if (resizeFailCount > 0) {
                             showMessage(`Resized ${resizeSuccessCount} frames. Failed to resize ${resizeFailCount}.`, 5000);
                        } else if (resizeSuccessCount > 0) {
                             showMessage(`Resized ${resizeSuccessCount} existing frames.`, 3000);
                        } else {
                             // This case might happen if no images actually needed resizing
                             console.log("No existing frames required resizing.");
                        }


                        redrawCanvas(); // Redraw with potentially resized images
                        startAnimation(); // Restart animation
                    });
            } else {
                // If frame size didn't change, just redraw and animate
                redrawCanvas();
                startAnimation();
            }
            // --- END: Resize existing frames ---
        }


        // --- Frame Import ---
        function handleImportFramesClick() { frameFileInput.click(); }
        /**
         * Handles the selection of individual frame files.
         * Reads files, resizes them if necessary using high-quality resampling,
         * and places them into the next available grid slots.
         */
        function handleFrameFileSelect(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            const totalFiles = files.length;
            let slotsAvailable = (gridRows * gridCols) - placedImages.length;

            if (totalFiles > slotsAvailable) {
                showMessage(`Warning: ${totalFiles} files selected, only ${slotsAvailable} slots available. Some files may be skipped.`, 5000);
            }
             if (frameWidth <= 0 || frameHeight <= 0) {
                 showMessage("Error: Invalid frame dimensions set. Cannot import frames.", 5000);
                 frameFileInput.value = ''; // Clear selection
                 return;
             }


            showMessage(`Processing ${totalFiles} frame(s)...`, 10000); // Show initial processing message

            const framePromises = []; // Array to hold promises for each file processing

            Array.from(files).forEach((file) => {
                const promise = new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = () => {
                            // --- Resizing Logic ---
                            const needsResize = img.naturalWidth !== frameWidth || img.naturalHeight !== frameHeight;
                            let finalImagePromise; // Promise for the potentially resized image

                            if (needsResize) {
                                console.log(`Resizing frame ${file.name} from ${img.naturalWidth}x${img.naturalHeight} to ${frameWidth}x${frameHeight}`);
                                finalImagePromise = new Promise((resolveResize, rejectResize) => {
                                    const resizeCanvas = document.createElement('canvas');
                                    resizeCanvas.width = frameWidth;
                                    resizeCanvas.height = frameHeight;
                                    const resizeCtx = resizeCanvas.getContext('2d');

                                    // Apply high-quality smoothing
                                    resizeCtx.imageSmoothingEnabled = true;
                                    resizeCtx.imageSmoothingQuality = 'high';

                                    try {
                                        // Draw the original loaded image onto the resize canvas
                                        resizeCtx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, 0, 0, frameWidth, frameHeight);

                                        // Create a new Image object from the resized canvas data
                                        const resizedImg = new Image();
                                        resizedImg.onload = () => {
                                            resolveResize(resizedImg); // Resolve with the resized image
                                        };
                                        resizedImg.onerror = (err) => {
                                            console.error(`Error loading resized image data for ${file.name}:`, err);
                                            rejectResize(new Error(`Failed to load resized image data for ${file.name}`));
                                        };
                                        resizedImg.src = resizeCanvas.toDataURL('image/png');
                                    } catch (resizeError) {
                                        console.error(`Error during canvas resizing for ${file.name}:`, resizeError);
                                        rejectResize(new Error(`Canvas resizing failed for ${file.name}`));
                                    }
                                });
                            } else {
                                // No resize needed, resolve immediately with the original image
                                finalImagePromise = Promise.resolve(img);
                            }

                            // Once the final image (original or resized) is ready...
                            finalImagePromise.then(finalImg => {
                                resolve({ img: finalImg, file: file }); // Resolve the main promise for this file
                            }).catch(err => {
                                reject(err); // Propagate resize/load errors
                            });
                            // --- End Resizing Logic ---
                        };
                        img.onerror = () => {
                            console.error(`Failed to load image data for: ${file.name}`);
                            reject(new Error(`Failed to load image data for ${file.name}`));
                        };
                        img.src = e.target.result; // Start loading the original image
                    };
                    reader.onerror = () => {
                        console.error(`Failed to read file: ${file.name}`);
                        reject(new Error(`Failed to read file ${file.name}`));
                    };
                    reader.readAsDataURL(file);
                });
                framePromises.push(promise);
            });

            // Function to find the next available slot (needed after promises resolve)
            function findNextAvailableSlot() {
                for (let r = 0; r < gridRows; r++) {
                    for (let c = 0; c < gridCols; c++) {
                        if (!placedImages.some(img => img.row === r && img.col === c)) {
                            return { row: r, col: c };
                        }
                    }
                }
                return null; // No slot available
            }

            // Process all promises once they settle
            Promise.allSettled(framePromises).then(results => {
                let imagesSuccessfullyPlaced = 0;
                let imagesFailedToLoadOrPlace = 0;

                results.forEach(result => {
                    if (result.status === 'fulfilled') {
                        const { img: finalImage, file } = result.value;
                        const slot = findNextAvailableSlot();
                        if (slot) {
                            placedImages.push({ img: finalImage, row: slot.row, col: slot.col, id: nextImageId++ });
                            imagesSuccessfullyPlaced++;
                        } else {
                            console.warn(`No slot available for ${file.name}.`);
                            imagesFailedToLoadOrPlace++;
                        }
                    } else {
                        console.error("Frame processing failed:", result.reason);
                        imagesFailedToLoadOrPlace++;
                    }
                });

                // Update UI after all processing is done
                redrawCanvas();
                startAnimation();
                showMessage(`Frame import finished: ${imagesSuccessfullyPlaced} placed, ${imagesFailedToLoadOrPlace} failed or skipped.`, 5000);
            });

            frameFileInput.value = ''; // Clear the file input
        }


        // --- Sprite Sheet Import ---
        function handleImportSheetClick() { sheetFileInput.click(); }

        function updateModalPreviewGridAndInputs(changedInputId) {
            if (isUpdatingModalInputs || !sourceSpriteSheetImage?.complete) return;
            isUpdatingModalInputs = true;

            const currentCols = parseInt(importSheetColsInput.value);
            const currentRows = parseInt(importSheetRowsInput.value);
            const currentWidth = parseInt(importSheetWidthInput.value);
            const currentHeight = parseInt(importSheetHeightInput.value);
            const marginLeft = parseInt(importMarginLeftInput.value) || 0;
            const marginTop = parseInt(importMarginTopInput.value) || 0;
            const marginRight = parseInt(importMarginRightInput.value) || 0;
            const marginBottom = parseInt(importMarginBottomInput.value) || 0;
            // Target size doesn't affect preview grid calculation, only final import

            const imgWidth = sourceSpriteSheetImage.width;
            const imgHeight = sourceSpriteSheetImage.height;
            const effectiveWidth = Math.max(0, imgWidth - marginLeft - marginRight);
            const effectiveHeight = Math.max(0, imgHeight - marginTop - marginBottom);

            try {
                 if (changedInputId?.startsWith('import-sheet-') || changedInputId?.startsWith('import-margin-')) {
                    if ((changedInputId === 'import-sheet-cols' || changedInputId === 'import-sheet-rows' || changedInputId?.startsWith('import-margin-')) && currentCols > 0 && currentRows > 0 && effectiveWidth > 0 && effectiveHeight > 0) {
                        const newFrameW = Math.floor(effectiveWidth / currentCols);
                        const newFrameH = Math.floor(effectiveHeight / currentRows);
                        if (newFrameW > 0 && !isNaN(newFrameW) && importSheetWidthInput.value !== String(newFrameW)) importSheetWidthInput.value = newFrameW;
                        else if (newFrameW <= 0 || isNaN(newFrameW)) importSheetWidthInput.value = '';
                        if (newFrameH > 0 && !isNaN(newFrameH) && importSheetHeightInput.value !== String(newFrameH)) importSheetHeightInput.value = newFrameH;
                        else if (newFrameH <= 0 || isNaN(newFrameH)) importSheetHeightInput.value = '';
                    }
                    else if ((changedInputId === 'import-sheet-width' || changedInputId === 'import-sheet-height') && currentWidth > 0 && currentHeight > 0 && effectiveWidth > 0 && effectiveHeight > 0) {
                        const newCols = Math.floor(effectiveWidth / currentWidth);
                        const newRows = Math.floor(effectiveHeight / currentHeight);
                        if (newCols > 0 && !isNaN(newCols) && importSheetColsInput.value !== String(newCols)) importSheetColsInput.value = newCols;
                        else if (newCols <= 0 || isNaN(newCols)) importSheetColsInput.value = '';
                        if (newRows > 0 && !isNaN(newRows) && importSheetRowsInput.value !== String(newRows)) importSheetRowsInput.value = newRows;
                         else if (newRows <= 0 || isNaN(newRows)) importSheetRowsInput.value = '';
                    }
                 }
            } catch (e) { console.error("Error during modal dimension recalculation:", e); }

            try {
                modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height);
                modalPreviewCtx.drawImage(sourceSpriteSheetImage, modalPreviewOffsetX, modalPreviewOffsetY, modalPreviewDrawnWidth, modalPreviewDrawnHeight);

                const previewMarginLeft = marginLeft * modalPreviewScaleFactor;
                const previewMarginTop = marginTop * modalPreviewScaleFactor;
                const previewMarginRight = marginRight * modalPreviewScaleFactor;
                const previewMarginBottom = marginBottom * modalPreviewScaleFactor;
                const previewEffectiveWidth = effectiveWidth * modalPreviewScaleFactor;
                const previewEffectiveHeight = effectiveHeight * modalPreviewScaleFactor;

                modalPreviewCtx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                modalPreviewCtx.fillRect(modalPreviewOffsetX, modalPreviewOffsetY, modalPreviewDrawnWidth, previewMarginTop);
                modalPreviewCtx.fillRect(modalPreviewOffsetX, modalPreviewOffsetY + previewMarginTop + previewEffectiveHeight, modalPreviewDrawnWidth, previewMarginBottom + 1);
                modalPreviewCtx.fillRect(modalPreviewOffsetX, modalPreviewOffsetY + previewMarginTop, previewMarginLeft, previewEffectiveHeight);
                modalPreviewCtx.fillRect(modalPreviewOffsetX + previewMarginLeft + previewEffectiveWidth, modalPreviewOffsetY + previewMarginTop, previewMarginRight + 1, previewEffectiveHeight);

                const finalCols = parseInt(importSheetColsInput.value);
                const finalRows = parseInt(importSheetRowsInput.value);
                const finalFrameW = parseInt(importSheetWidthInput.value);
                const finalFrameH = parseInt(importSheetHeightInput.value);

                if (isNaN(finalCols) || isNaN(finalRows) || isNaN(finalFrameW) || isNaN(finalFrameH) || finalCols < 1 || finalRows < 1 || finalFrameW <= 0 || finalFrameH <= 0) {
                    // console.warn("Invalid dimensions for modal preview grid.");
                } else {
                    const previewGridStartX = modalPreviewOffsetX + previewMarginLeft;
                    const previewGridStartY = modalPreviewOffsetY + previewMarginTop;
                    const previewFrameW = finalFrameW * modalPreviewScaleFactor;
                    const previewFrameH = finalFrameH * modalPreviewScaleFactor;

                    modalPreviewCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; modalPreviewCtx.lineWidth = 1;
                    for (let i = 1; i < finalCols; i++) {
                        const x = previewGridStartX + i * previewFrameW;
                        modalPreviewCtx.beginPath(); modalPreviewCtx.moveTo(x, previewGridStartY); modalPreviewCtx.lineTo(x, previewGridStartY + previewEffectiveHeight); modalPreviewCtx.stroke();
                    }
                    for (let i = 1; i < finalRows; i++) {
                        const y = previewGridStartY + i * previewFrameH;
                        modalPreviewCtx.beginPath(); modalPreviewCtx.moveTo(previewGridStartX, y); modalPreviewCtx.lineTo(previewGridStartX + previewEffectiveWidth, y); modalPreviewCtx.stroke();
                    }
                }
            } catch (e) { console.error("Error drawing modal preview:", e); }
            isUpdatingModalInputs = false;
        }

        function handleSheetFileSelect(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                sourceSpriteSheetImage = new Image();
                sourceSpriteSheetImage.onload = () => {
                    const maxWidth = 450; const maxHeight = 300;
                    const imgWidth = sourceSpriteSheetImage.width; const imgHeight = sourceSpriteSheetImage.height;
                    const widthScale = maxWidth / imgWidth; const heightScale = maxHeight / imgHeight;
                    modalPreviewScaleFactor = Math.min(widthScale, heightScale, 1);
                    modalPreviewDrawnWidth = imgWidth * modalPreviewScaleFactor; modalPreviewDrawnHeight = imgHeight * modalPreviewScaleFactor;
                    modalPreviewCanvas.width = modalPreviewDrawnWidth > 0 ? modalPreviewDrawnWidth : maxWidth;
                    modalPreviewCanvas.height = modalPreviewDrawnHeight > 0 ? modalPreviewDrawnHeight : maxHeight;
                    modalPreviewOffsetX = (modalPreviewCanvas.width - modalPreviewDrawnWidth) / 2; modalPreviewOffsetY = (modalPreviewCanvas.height - modalPreviewDrawnHeight) / 2;

                    // Reset margins, target sizes and guess dimensions
                    importMarginLeftInput.value = 0; importMarginTopInput.value = 0;
                    importMarginRightInput.value = 0; importMarginBottomInput.value = 0;
                    importTargetWidthInput.value = ''; importTargetHeightInput.value = ''; // Clear target size
                    const effectiveWidth = imgWidth; const effectiveHeight = imgHeight;
                    const aspect = effectiveWidth / effectiveHeight; let guessCols = 4, guessRows = 4;
                    if (aspect > 1.5 && effectiveHeight > 0) { guessCols = 8; guessRows = Math.max(1, Math.round(8 / aspect)); } else if (aspect < 0.6 && effectiveWidth > 0) { guessRows = 8; guessCols = Math.max(1, Math.round(8 * aspect)); }
                    let guessFrameW = (guessCols > 0) ? Math.floor(effectiveWidth / guessCols) : effectiveWidth; let guessFrameH = (guessRows > 0) ? Math.floor(effectiveHeight / guessRows) : effectiveHeight;
                    if (guessFrameW <= 0) guessFrameW = 1; if (guessFrameH <= 0) guessFrameH = 1;
                    if (guessCols <= 0) guessCols = Math.max(1, Math.floor(effectiveWidth / guessFrameW)); if (guessRows <= 0) guessRows = Math.max(1, Math.floor(effectiveHeight / guessFrameH));
                    importSheetColsInput.value = guessCols; importSheetRowsInput.value = guessRows; importSheetWidthInput.value = guessFrameW; importSheetHeightInput.value = guessFrameH;

                    // --- Re-attach Event Listeners (Including Margins & Target Size) ---
                    const inputsToClone = [
                        { current: importSheetColsInput, id: 'import-sheet-cols' },
                        { current: importSheetRowsInput, id: 'import-sheet-rows' },
                        { current: importSheetWidthInput, id: 'import-sheet-width' },
                        { current: importSheetHeightInput, id: 'import-sheet-height' },
                        { current: importMarginLeftInput, id: 'import-margin-left' },
                        { current: importMarginTopInput, id: 'import-margin-top' },
                        { current: importMarginRightInput, id: 'import-margin-right' },
                        { current: importMarginBottomInput, id: 'import-margin-bottom' },
                        { current: importTargetWidthInput, id: 'import-target-width' }, // NEW
                        { current: importTargetHeightInput, id: 'import-target-height' } // NEW
                    ];
                    inputsToClone.forEach(item => {
                        const newNode = item.current.cloneNode(true);
                        item.current.parentNode.replaceChild(newNode, item.current);
                        // Update the reference in the outer scope
                        if (item.id === 'import-sheet-cols') importSheetColsInput = newNode;
                        else if (item.id === 'import-sheet-rows') importSheetRowsInput = newNode;
                        else if (item.id === 'import-sheet-width') importSheetWidthInput = newNode;
                        else if (item.id === 'import-sheet-height') importSheetHeightInput = newNode;
                        else if (item.id === 'import-margin-left') importMarginLeftInput = newNode;
                        else if (item.id === 'import-margin-top') importMarginTopInput = newNode;
                        else if (item.id === 'import-margin-right') importMarginRightInput = newNode;
                        else if (item.id === 'import-margin-bottom') importMarginBottomInput = newNode;
                        else if (item.id === 'import-target-width') importTargetWidthInput = newNode; // NEW
                        else if (item.id === 'import-target-height') importTargetHeightInput = newNode; // NEW

                        // Add listener to the new node (only grid/margin inputs need to update preview)
                        if (!item.id.startsWith('import-target-')) {
                             newNode.addEventListener('input', () => updateModalPreviewGridAndInputs(item.id));
                        }
                    });
                    // --- End Re-attaching Listeners ---

                    updateModalPreviewGridAndInputs(null); // Draw initial preview
                    importSheetModal.classList.remove('hidden');
                };
                sourceSpriteSheetImage.onerror = () => { showMessage("Error: Could not load image file.", 5000); sourceSpriteSheetImage = null; };
                sourceSpriteSheetImage.src = e.target.result;
            }
            reader.onerror = () => { showMessage("Error: Could not read file.", 5000); }
            reader.readAsDataURL(file); sheetFileInput.value = '';
        }
        function handleCancelImportSheet() {
            importSheetModal.classList.add('hidden'); sourceSpriteSheetImage = null;
            modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height);
            // Clone/replace inputs to remove listeners
            const inputsToClean = [importSheetColsInput, importSheetRowsInput, importSheetWidthInput, importSheetHeightInput, importMarginLeftInput, importMarginTopInput, importMarginRightInput, importMarginBottomInput, importTargetWidthInput, importTargetHeightInput]; // Added target inputs
            inputsToClean.forEach(input => {
                if (input && input.parentNode) {
                    const cleanNode = input.cloneNode(true);
                    input.parentNode.replaceChild(cleanNode, input);
                    // Update outer scope reference
                    if (input.id === 'import-sheet-cols') importSheetColsInput = cleanNode;
                    else if (input.id === 'import-sheet-rows') importSheetRowsInput = cleanNode;
                    else if (input.id === 'import-sheet-width') importSheetWidthInput = cleanNode;
                    else if (input.id === 'import-sheet-height') importSheetHeightInput = cleanNode;
                    else if (input.id === 'import-margin-left') importMarginLeftInput = cleanNode;
                    else if (input.id === 'import-margin-top') importMarginTopInput = cleanNode;
                    else if (input.id === 'import-margin-right') importMarginRightInput = cleanNode;
                    else if (input.id === 'import-margin-bottom') importMarginBottomInput = cleanNode;
                    else if (input.id === 'import-target-width') importTargetWidthInput = cleanNode; // NEW
                    else if (input.id === 'import-target-height') importTargetHeightInput = cleanNode; // NEW
                }
            });
        }
        /**
         * Handles loading the sheet: validates inputs, slices frames respecting margins,
         * resamples frames if target size is specified, and updates the main editor.
         */
        function handleLoadSpriteSheet() {
            // Read values from modal
            const importCols = parseInt(importSheetColsInput.value);
            const importRows = parseInt(importSheetRowsInput.value);
            const importFrameW = parseInt(importSheetWidthInput.value); // Original frame width from grid calc
            const importFrameH = parseInt(importSheetHeightInput.value); // Original frame height from grid calc
            const marginLeft = parseInt(importMarginLeftInput.value) || 0;
            const marginTop = parseInt(importMarginTopInput.value) || 0;
            const marginRight = parseInt(importMarginRightInput.value) || 0;
            const marginBottom = parseInt(importMarginBottomInput.value) || 0;
            // Read target dimensions, default to original calculated size if empty or invalid
            let targetWidth = parseInt(importTargetWidthInput.value);
            let targetHeight = parseInt(importTargetHeightInput.value);
            targetWidth = (!isNaN(targetWidth) && targetWidth > 0) ? targetWidth : importFrameW;
            targetHeight = (!isNaN(targetHeight) && targetHeight > 0) ? targetHeight : importFrameH;


            // Validate basic inputs
            if (isNaN(importCols) || isNaN(importRows) || isNaN(importFrameW) || isNaN(importFrameH) || importCols < 1 || importRows < 1 || importFrameW < 1 || importFrameH < 1) { showMessage("Invalid dimensions calculated.", 4000); return; }
            if (marginLeft < 0 || marginTop < 0 || marginRight < 0 || marginBottom < 0) { showMessage("Margins cannot be negative.", 4000); return; }
             if (targetWidth <=0 || targetHeight <= 0) { showMessage("Target dimensions must be positive.", 4000); return; }
            if (!sourceSpriteSheetImage?.complete) { showMessage("Error: Source image missing.", 4000); return; }

            // Calculate effective area and validate against image size
            const effectiveWidth = sourceSpriteSheetImage.width - marginLeft - marginRight;
            const effectiveHeight = sourceSpriteSheetImage.height - marginTop - marginBottom;
            if (effectiveWidth <= 0 || effectiveHeight <= 0) { showMessage("Margins are larger than the image dimensions.", 4000); return; }
            // Check if grid dimensions exceed the effective area (allow 1px tolerance for rounding)
            if (importCols * importFrameW > effectiveWidth + 1 || importRows * importFrameH > effectiveHeight + 1) {
                 if (!confirm(`Warning: Calculated grid dimensions (${importCols}x${importRows} frames of ${importFrameW}x${importFrameH}px) might exceed the effective area (${effectiveWidth}x${effectiveHeight}px) within margins. This might result in fewer frames being loaded. Continue anyway?`)) { return; }
            }

            console.log(`Loading: ${importCols}x${importRows} frames, original size ${importFrameW}x${importFrameH}px, target size ${targetWidth}x${targetHeight}px. Margins(L,T,R,B): ${marginLeft},${marginTop},${marginRight},${marginBottom}`);
            showMessage("Processing sheet (slicing and resampling)...", 15000); // Longer message

            // Update main editor state using TARGET dimensions
            gridColsInput.value = importCols;
            gridRowsInput.value = importRows;
            frameWidthInput.value = targetWidth; // Use target width
            frameHeightInput.value = targetHeight; // Use target height
            handleSizeChange(); // Update main state, canvas size etc. using TARGET size

            // Clear current frames and selection
            placedImages = []; nextImageId = 0;
            selectedFrameIds.clear();
            lastSelectedFrameId = null;

            const promises = [];
            for (let r = 0; r < importRows; r++) {
                for (let c = 0; c < importCols; c++) {
                    const sx = marginLeft + c * importFrameW;
                    const sy = marginTop + r * importFrameH;

                    if (sx < 0 || sy < 0 || sx + importFrameW > sourceSpriteSheetImage.width || sy + importFrameH > sourceSpriteSheetImage.height) {
                         console.warn(`Skipping frame at [${r},${c}]: Source rect extends beyond source image bounds.`);
                         continue;
                    }

                    const framePromise = new Promise((resolve, reject) => {
                        const frameCanvas = document.createElement('canvas'); // Canvas for original slice
                        frameCanvas.width = importFrameW; frameCanvas.height = importFrameH;
                        const frameCtx = frameCanvas.getContext('2d');
                        try {
                            // 1. Extract the original frame portion
                            frameCtx.drawImage(sourceSpriteSheetImage, sx, sy, importFrameW, importFrameH, 0, 0, importFrameW, importFrameH);

                            // 2. Determine if resizing is needed
                            const needsResize = (targetWidth !== importFrameW || targetHeight !== importFrameH);
                            let finalCanvas = frameCanvas; // Default to original canvas

                            if (needsResize) {
                                // 3. Create canvas for resized frame
                                const resizedFrameCanvas = document.createElement('canvas');
                                resizedFrameCanvas.width = targetWidth;
                                resizedFrameCanvas.height = targetHeight;
                                const resizedCtx = resizedFrameCanvas.getContext('2d');

                                // 4. Set smoothing for better anti-aliasing
                                resizedCtx.imageSmoothingEnabled = true;
                                resizedCtx.imageSmoothingQuality = 'high';

                                // 5. Draw (resample) from original slice canvas to resized canvas
                                resizedCtx.drawImage(frameCanvas, 0, 0, importFrameW, importFrameH, 0, 0, targetWidth, targetHeight);
                                finalCanvas = resizedFrameCanvas; // Use the resized canvas for the final image
                            }

                            // 6. Create Image object from the final canvas (original or resized)
                            const frameImg = new Image();
                            frameImg.onload = () => resolve({ img: frameImg, row: r, col: c }); // Store with target grid row/col
                            frameImg.onerror = (err) => { console.error(`Err load frame [${r}, ${c}]`, err); reject(`Failed load ${r}-${c}`); };
                            frameImg.src = finalCanvas.toDataURL('image/png'); // Get data URL from final canvas

                        } catch (e) { console.error(`Err draw/resize frame [${r}, ${c}]`, e); reject(`Failed draw/resize ${r}-${c}`); }
                    });
                    promises.push(framePromise);
                }
            }
            Promise.all(promises)
                 .then((loadedFramesData) => {
                      placedImages = loadedFramesData.map(data => ({ img: data.img, row: data.row, col: data.col, id: nextImageId++ }));
                      console.log("Frames processed and placedImages updated.");
                      redrawCanvas(); // Redraw main canvas (now uses target size)
                      startAnimation(); // Restart animation
                      showMessage(`Sheet loaded! ${loadedFramesData.length} frames created (resampled to ${targetWidth}x${targetHeight}px).`, 5000);
                 })
                 .catch((error) => {
                      console.error("Error processing frames from promise:", error);
                      showMessage(`Error loading sheet: ${error}.`, 5000);
                      redrawCanvas(); startAnimation(); // Still attempt redraw/animate
                 })
                 .finally(() => {
                      handleCancelImportSheet(); // Close modal
                 });
        }

        // --- Save Handlers ---
        function handleSaveClick() {
            if (placedImages.length === 0) { showMessage("Nothing to save."); return; }
            saveFilenameInput.value = "spritesheet"; saveByRowCheckbox.checked = false;
            saveModal.classList.remove('hidden');
        }
        function hideSaveModal() { saveModal.classList.add('hidden'); }
        function executeSave() {
            const baseFilename = saveFilenameInput.value.trim() || "spritesheet";
            const saveByRow = saveByRowCheckbox.checked;
            hideSaveModal();
            if (saveByRow) { saveSheetByRow(baseFilename); }
            else { saveEntireSheet(baseFilename); }
        }
        function saveEntireSheet(filename) {
             console.log("Saving entire sheet as:", filename);
             if (placedImages.length === 0) { showMessage("Nothing to save."); return; }
             const fullFilename = filename.toLowerCase().endsWith('.png') ? filename : filename + '.png';
             const tempCanvas = document.createElement('canvas');
             try {
                 // Use current gridCols/frameWidth which reflect loaded state (potentially target size)
                 const requiredWidth = gridCols * frameWidth;
                 const requiredHeight = gridRows * frameHeight;
                 if (requiredWidth <= 0 || requiredHeight <= 0) { showMessage("Cannot save: Invalid dimensions."); return; }
                 tempCanvas.width = requiredWidth; tempCanvas.height = requiredHeight;
                 const tempCtx = tempCanvas.getContext('2d'); let imagesDrawn = 0;
                 placedImages.forEach(item => { if (item?.img?.complete) { try { tempCtx.drawImage(item.img, item.col * frameWidth, item.row * frameHeight, frameWidth, frameHeight); imagesDrawn++; } catch (e) { console.error(`Err draw ID ${item.id}`, e); } } else { console.warn(`Skip unload ID ${item?.id}`); } });
                 if (imagesDrawn === 0 && placedImages.length > 0) { showMessage("Error: Could not draw images.", 5000); return; }
                 const dataURL = tempCanvas.toDataURL('image/png'); triggerDownload(dataURL, fullFilename);
                 showMessage(`Saved sheet as ${fullFilename}! (${imagesDrawn} frames)`);
             } catch (e) { console.error("Error saving entire sheet:", e); showMessage("Error saving sheet. Check console.", 5000); }
        }
        function saveSheetByRow(baseFilename) {
            console.log("Saving sheet by row, base filename:", baseFilename);
            if (placedImages.length === 0) { showMessage("Nothing to save."); return; }
            let filesSavedCount = 0; let maxRow = -1;
            placedImages.forEach(img => { if (img.row > maxRow) maxRow = img.row; });
            if (maxRow < 0) { showMessage("No rows found."); return; }
            try {
                for (let r = 0; r <= maxRow; r++) {
                    const rowFrames = placedImages.filter(item => item.row === r).sort((a, b) => a.col - b.col);
                    if (rowFrames.length === 0) continue;
                     // Use current frameWidth/Height which reflect loaded state (target size)
                    const rowSheetWidth = rowFrames.length * frameWidth;
                    const rowSheetHeight = frameHeight;
                    if (rowSheetWidth <= 0 || rowSheetHeight <= 0) { console.warn(`Skip row ${r}: Invalid dimensions.`); continue; }
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = rowSheetWidth; tempCanvas.height = rowSheetHeight;
                    const tempCtx = tempCanvas.getContext('2d'); let imagesDrawnThisRow = 0;
                    rowFrames.forEach((item, index) => { if (item?.img?.complete) { try { tempCtx.drawImage(item.img, index * frameWidth, 0, frameWidth, frameHeight); imagesDrawnThisRow++; } catch (e) { console.error(`Err draw ID ${item.id} for row ${r}`, e); } } else { console.warn(`Skip unload ID ${item?.id} for row ${r}`); } });
                    if (imagesDrawnThisRow > 0) { const filename = `${baseFilename}_row${r}.png`; const dataURL = tempCanvas.toDataURL('image/png'); triggerDownload(dataURL, filename); filesSavedCount++; }
                    else { console.warn(`Skip save row ${r}: No images drawn.`); }
                }
                if (filesSavedCount > 0) { showMessage(`Saved ${filesSavedCount} row file(s) starting with '${baseFilename}'.`); }
                else { showMessage("No rows with drawable frames found."); }
            } catch (e) { console.error("Error saving by row:", e); showMessage("Error saving rows. Check console.", 5000); }
        }

        // --- Delete Handler ---
        function handleDeleteSelected() {
             if (selectedFrameIds.size === 0) {
                 showMessage("No frames selected.");
                 return;
             }
             const originalCount = placedImages.length;
             const idsToDelete = new Set(selectedFrameIds); // Copy the set

             placedImages = placedImages.filter(item => !idsToDelete.has(item.id));

             const deletedCount = originalCount - placedImages.length;
             console.log(`Deleted ${deletedCount} frames.`);

             selectedFrameIds.clear(); // Clear selection
             lastSelectedFrameId = null; // Clear last selected anchor
             redrawCanvas();
             startAnimation();
             showMessage(`${deletedCount} frame(s) deleted.`);
        }

        // --- Drag and Drop & Selection Logic ---
        function getMousePos(canvasEl, evt) { const rect = canvasEl.getBoundingClientRect(); const clientX = evt.clientX ?? evt.touches?.[0]?.clientX; const clientY = evt.clientY ?? evt.touches?.[0]?.clientY; if (typeof clientX !== 'number' || typeof clientY !== 'number') { console.warn("No mouse pos."); return null; } return { x: clientX - rect.left, y: clientY - rect.top }; }

        function handleMouseDown(event) {
             const pos = getMousePos(canvas, event); if (!pos) return;
             if (event.type === 'touchstart') event.preventDefault(); // Prevent touch scrolling

             const isShiftPressed = event.shiftKey;
             dragStartCanvasX = pos.x; dragStartCanvasY = pos.y;
             dragStartClientX = event.clientX ?? event.touches?.[0]?.clientX;
             dragStartClientY = event.clientY ?? event.touches?.[0]?.clientY;
             dragMoved = false;

             // Calculate clicked grid cell
             const clickedCol = Math.floor(pos.x / frameWidth);
             const clickedRow = Math.floor(pos.y / frameHeight);

             // Check if click is within grid bounds
             if (clickedCol < 0 || clickedCol >= gridCols || clickedRow < 0 || clickedRow >= gridRows || frameWidth <= 0 || frameHeight <= 0) {
                 // Clicked outside grid, deselect all
                 if (selectedFrameIds.size > 0) {
                     selectedFrameIds.clear();
                     lastSelectedFrameId = null;
                     redrawCanvas();
                     startAnimation();
                 }
                 draggedImage = null;
                 isDragging = false;
                 return;
             }

             const clickedImage = placedImages.find(item => item.row === clickedRow && item.col === clickedCol);
             const clickedImageId = clickedImage ? clickedImage.id : null;

             if (isShiftPressed && lastSelectedFrameId !== null) {
                 // --- Shift+Click Logic ---
                 const lastSelectedItem = placedImages.find(item => item.id === lastSelectedFrameId);
                 if (lastSelectedItem && clickedImage) { // Need both start and end points
                     const startRow = Math.min(lastSelectedItem.row, clickedRow);
                     const endRow = Math.max(lastSelectedItem.row, clickedRow);
                     const startCol = Math.min(lastSelectedItem.col, clickedCol);
                     const endCol = Math.max(lastSelectedItem.col, clickedCol);

                     // selectedFrameIds.clear(); // Don't clear, add to existing selection? Or replace? Let's replace for now.
                     // Keep existing selection and add range:
                     // selectedFrameIds = new Set(selectedFrameIds); // Ensure it's a new set if modifying

                     // Standard behavior: Clear previous and select range
                     selectedFrameIds.clear();

                     placedImages.forEach(item => {
                         if (item.row >= startRow && item.row <= endRow && item.col >= startCol && item.col <= endCol) {
                             selectedFrameIds.add(item.id);
                         }
                     });
                     console.log(`Shift+Click: Selected range [${startRow},${startCol}] to [${endRow},${endCol}]. Total: ${selectedFrameIds.size}`);
                 } else if (clickedImage) {
                     // Shift click but no previous anchor, or clicked empty cell - treat as normal click
                     selectedFrameIds.clear();
                     selectedFrameIds.add(clickedImageId);
                     lastSelectedFrameId = clickedImageId;
                 } else {
                     // Shift click on empty cell with anchor - do nothing? Or select rect to empty cell? Let's do nothing.
                     console.log("Shift+Click on empty cell with anchor - ignored.");
                 }
                 draggedImage = null; // Disable dragging during shift selection
                 isDragging = false;

             } else {
                 // --- Normal Click Logic ---
                 if (clickedImage) {
                     // Clicked on an existing frame
                     selectedFrameIds.clear(); // Clear previous selection
                     selectedFrameIds.add(clickedImageId);
                     lastSelectedFrameId = clickedImageId; // Set anchor for potential shift-click

                     // Prepare for potential drag ONLY if one item is selected
                     draggedImage = clickedImage;
                     isDragging = false; // Reset dragging state
                     dragOffsetX = pos.x - (draggedImage.col * frameWidth);
                     dragOffsetY = pos.y - (draggedImage.row * frameHeight);
                     canvas.style.cursor = 'grab';
                     console.log(`Clicked frame ID: ${clickedImageId}`);

                 } else {
                     // Clicked on an empty cell
                     selectedFrameIds.clear(); // Deselect all
                     lastSelectedFrameId = null; // Clear anchor
                     draggedImage = null;
                     isDragging = false;
                     canvas.style.cursor = 'default';
                     console.log("Clicked empty cell.");
                 }
             }

             redrawCanvas();
             startAnimation(); // Update animation based on (last) selection
        }

        function handleMouseMove(event) {
             // Only allow dragging if exactly one frame was initially clicked (draggedImage is set)
             // and shift wasn't pressed. Dragging is disabled for multi-selection.
             if (!draggedImage || selectedFrameIds.size !== 1) return;

             const currentX = event.clientX ?? event.touches?.[0]?.clientX;
             const currentY = event.clientY ?? event.touches?.[0]?.clientY;
             if (typeof currentX !== 'number' || typeof currentY !== 'number') return;

             const moveThreshold = 5; // Pixels threshold to start drag

             // Check if dragging hasn't started yet and threshold is met
             if (!isDragging && (Math.abs(currentX - dragStartClientX) > moveThreshold || Math.abs(currentY - dragStartClientY) > moveThreshold)) {
                 isDragging = true;
                 dragMoved = true; // Mark that the mouse actually moved significantly
                 canvas.style.cursor = 'grabbing';
                 console.log("Drag start ID:", draggedImage.id);
                 redrawCanvas(); // Redraw to hide original position
             }

             // If dragging is active, update position and redraw
             if (isDragging) {
                 if (event.type === 'touchmove') event.preventDefault(); // Prevent scrolling on touch devices
                 const pos = getMousePos(canvas, event);
                 if (!pos) return;
                 dragStartCanvasX = pos.x; // Update current drag position for drawing
                 dragStartCanvasY = pos.y;
                 redrawCanvas(); // Redraw to show image at new position
             }
        }

        function handleMouseUp(event) {
             const wasDragging = isDragging;
             const currentlyDragged = draggedImage; // Store ref before clearing

             if (isDragging && currentlyDragged) { // Ensure we were dragging a valid image
                 isDragging = false;
                 canvas.style.cursor = 'default'; // Reset cursor immediately
                 let requiresAnimationUpdate = false;

                 const pos = getMousePos(canvas, event);
                 if (pos && frameWidth > 0 && frameHeight > 0) {
                     const targetCol = Math.floor(pos.x / frameWidth);
                     const targetRow = Math.floor(pos.y / frameHeight);

                     // Check if drop target is valid and empty
                     if (targetCol >= 0 && targetCol < gridCols && targetRow >= 0 && targetRow < gridRows) {
                         const existingImage = placedImages.find(item => item.row === targetRow && item.col === targetCol && item.id !== currentlyDragged.id);

                         if (!existingImage) {
                             // Valid drop, update position
                             if (currentlyDragged.row !== targetRow) requiresAnimationUpdate = true; // Row changed, update animation
                             currentlyDragged.row = targetRow;
                             currentlyDragged.col = targetCol;
                             // Keep it selected (already selected in mousedown)
                             // lastSelectedFrameId = currentlyDragged.id; // Keep anchor
                             console.log(`Drop ID ${currentlyDragged.id} at [${targetRow}, ${targetCol}]`);
                         } else {
                             // Target occupied, snap back (redraw will handle this as position wasn't updated)
                             showMessage("Target cell occupied.");
                             console.log(`Drop fail ID ${currentlyDragged.id}: target [${targetRow}, ${targetCol}] occupied`);
                         }
                     } else {
                         // Dropped outside grid, snap back
                         showMessage("Dropped outside grid.");
                         console.log(`Drop fail ID ${currentlyDragged.id}: outside grid`);
                     }
                 } else {
                     console.warn("Could not get drop location or invalid frame size.");
                 }
                 draggedImage = null; // Clear dragged image reference
                 redrawCanvas(); // Redraw to show final position or snap back
                 if (requiresAnimationUpdate || selectedFrameIds.size > 0) {
                     startAnimation(); // Update animation if row changed or still selected
                 }

             } else if (currentlyDragged && !dragMoved) {
                 // This was a click, not a drag. Selection handled in mousedown.
                 console.log(`Click finished on ID ${currentlyDragged.id}. Selection size: ${selectedFrameIds.size}`);
                 canvas.style.cursor = 'grab'; // Keep grab cursor until mouse moves off
             } else {
                  // Clicked empty space or finished shift-click
                  canvas.style.cursor = 'default';
             }

             // Reset drag state variables
             if (!isDragging) draggedImage = null; // Ensure cleared if not dragging
             dragMoved = false;
        }

        function handleMouseLeave(event) {
             // If dragging, cancel the drag and snap back
             if (isDragging) {
                 const previouslyDragged = draggedImage;
                 isDragging = false;
                 draggedImage = null;
                 canvas.style.cursor = 'default';
                 redrawCanvas(); // Redraw to snap back
                 showMessage("Drag cancelled.");
                 console.log(`Drag cancel ID ${previouslyDragged?.id}`);
                 // Keep selection state as it was before drag started
                 startAnimation(); // Update animation based on selection
             }
             // Reset grab cursor if leaving after a simple click
             else if (canvas.style.cursor === 'grab') {
                 canvas.style.cursor = 'default';
             }
        }

        // --- Animation Functions ---
        function stopAnimation() { if (animationIntervalId !== null) { clearInterval(animationIntervalId); animationIntervalId = null; } }
        function runAnimationLoop() {
            if (animationPreviewCanvas.width <= 0 || animationPreviewCanvas.height <= 0) { stopAnimation(); return; }
            if (!framesToAnimate || framesToAnimate.length === 0) { animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height); return; }
            const currentFrameData = framesToAnimate[currentAnimationFrameIndex];
            animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);
            if (currentFrameData?.img?.complete) { try { animationPreviewCtx.drawImage(currentFrameData.img, 0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height); } catch (e) { console.error("Error drawing animation frame:", e); animationPreviewCtx.fillStyle = 'red'; animationPreviewCtx.fillText('!', animationPreviewCanvas.width / 2, animationPreviewCanvas.height / 2); } }
            else { animationPreviewCtx.fillStyle = '#9ca3af'; animationPreviewCtx.textAlign = 'center'; animationPreviewCtx.textBaseline = 'middle'; animationPreviewCtx.fillText('...', animationPreviewCanvas.width / 2, animationPreviewCanvas.height / 2); }
            currentAnimationFrameIndex = (currentAnimationFrameIndex + 1) % framesToAnimate.length;
        }
        function startAnimation() {
            stopAnimation();

            // Animate the row of the last selected frame, or all frames if none selected
            let animationRow = -1;
            if (lastSelectedFrameId !== null) {
                const lastSelectedItem = placedImages.find(item => item.id === lastSelectedFrameId);
                if (lastSelectedItem) {
                    animationRow = lastSelectedItem.row;
                }
            }

            if (animationRow !== -1) {
                framesToAnimate = placedImages.filter(item => item.row === animationRow).sort((a, b) => a.col - b.col);
            } else {
                // If no specific frame is 'last selected', animate all frames
                framesToAnimate = [...placedImages].sort((a, b) => a.row - b.row || a.col - b.col);
            }


            currentAnimationFrameIndex = 0;
            if (framesToAnimate.length > 0 && animationFps > 0) { const intervalDelay = 1000 / animationFps; animationIntervalId = setInterval(runAnimationLoop, intervalDelay); }
            else { animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height); }
        }
        function handleFpsChange() {
            const newFps = parseInt(animationFpsInput.value);
            if (!isNaN(newFps) && newFps >= 1 && newFps <= 60) { animationFps = newFps; console.log(`Animation FPS changed to: ${animationFps}`); startAnimation(); }
            else { animationFpsInput.value = animationFps; showMessage("Invalid FPS value (1-60).", 4000); }
        }

        // --- Downsample Functions ---
        function showDownsampleModal() {
            if (placedImages.length === 0) { showMessage("No frames loaded to downsample."); return; }
            downsampleRatioInput.value = "2"; downsampleModal.classList.remove('hidden');
        }
        function hideDownsampleModal() { downsampleModal.classList.add('hidden'); }
        function handleApplyDownsample() {
            const ratioN = parseInt(downsampleRatioInput.value);
            if (isNaN(ratioN) || ratioN < 2) { showMessage("Invalid downsample ratio (>= 2).", 4000); return; }
            if (placedImages.length === 0) { showMessage("No frames to downsample."); hideDownsampleModal(); return; }
            console.log(`Downsampling with ratio N = ${ratioN}`);
            const downsampledImages = []; let maxColsNeeded = 0; let maxRow = -1;
            placedImages.forEach(img => { if (img.row > maxRow) maxRow = img.row; });

            const idsToKeep = new Set(); // Keep track of IDs that survive downsampling

            for (let r = 0; r <= maxRow; r++) {
                const rowFrames = placedImages.filter(item => item.row === r).sort((a, b) => a.col - b.col);
                if (rowFrames.length === 0) continue;
                let newColIndex = 0;
                for (let i = 0; i < rowFrames.length; i++) {
                    if (i % ratioN === 0) {
                        const frameToKeep = rowFrames[i];
                        frameToKeep.col = newColIndex; // Update column index
                        downsampledImages.push(frameToKeep);
                        idsToKeep.add(frameToKeep.id); // Add its ID to the keep set
                        newColIndex++;
                    }
                }
                maxColsNeeded = Math.max(maxColsNeeded, newColIndex);
            }
            const originalCount = placedImages.length; placedImages = downsampledImages; const newCount = placedImages.length;
            const newGridCols = newCount > 0 ? Math.max(1, maxColsNeeded) : parseInt(gridColsInput.value);
            if (newGridCols !== gridCols) { gridCols = newGridCols; gridColsInput.value = gridCols; console.log(`Grid columns updated to ${gridCols}`); }

            // Update selection: remove IDs that were deleted
            const currentSelected = new Set(selectedFrameIds);
            selectedFrameIds.clear();
            currentSelected.forEach(id => {
                if (idsToKeep.has(id)) {
                    selectedFrameIds.add(id);
                }
            });
            // Reset last selected if it was deleted
            if (lastSelectedFrameId !== null && !idsToKeep.has(lastSelectedFrameId)) {
                lastSelectedFrameId = null;
            }


            redrawCanvas(); startAnimation(); hideDownsampleModal();
            showMessage(`Downsampling complete. Kept ${newCount}/${originalCount} frames. Grid cols set to ${gridCols}.`, 5000);
        }


        // --- Event Listeners ---
        gridColsInput.addEventListener('change', handleSizeChange);
        gridRowsInput.addEventListener('change', handleSizeChange);
        frameWidthInput.addEventListener('change', handleSizeChange);
        frameHeightInput.addEventListener('change', handleSizeChange);
        animationFpsInput.addEventListener('change', handleFpsChange);

        importFramesButton.addEventListener('click', handleImportFramesClick);
        importSheetButton.addEventListener('click', handleImportSheetClick);
        frameFileInput.addEventListener('change', handleFrameFileSelect);
        sheetFileInput.addEventListener('change', handleSheetFileSelect);
        saveButton.addEventListener('click', handleSaveClick); // Opens save modal
        deleteFrameButton.addEventListener('click', handleDeleteSelected);

        // Modal Listeners (Import Sheet - listeners for inputs added dynamically)
        cancelImportSheetButton.addEventListener('click', handleCancelImportSheet);
        loadSheetButton.addEventListener('click', handleLoadSpriteSheet);

        // Downsample Listeners
        downsampleButton.addEventListener('click', showDownsampleModal);
        cancelDownsampleButton.addEventListener('click', hideDownsampleModal);
        applyDownsampleButton.addEventListener('click', handleApplyDownsample);

        // Save Modal Listeners
        cancelSaveButton.addEventListener('click', hideSaveModal);
        confirmSaveButton.addEventListener('click', executeSave);

        // Canvas Listeners
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseLeave);
        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleMouseUp);
        canvas.addEventListener('touchcancel', handleMouseLeave);


        // --- Initial Setup ---
        redrawCanvas();
        startAnimation();
        console.log("Sprite Sheet Editor Initialized.");

    </script>

</body>
</html>
