<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
        canvas#sprite-canvas { /* Target main canvas */
            border: 1px solid #d1d5db; /* gray-300 */
            cursor: default; /* Default cursor, change on hover/drag */
            touch-action: none; /* Prevent default touch actions like scrolling */
            background-color: #f9fafb; /* Add a light background */
            display: block; /* Prevent extra space */
        }

        .control-panel label,
        .modal-content label,
        #animation-preview-container label { /* Apply label style */
            @apply block text-sm font-medium text-gray-700 mb-1;
        }

        /* --- Custom CSS Input Styles (Applied via .gui-input class) --- */
        .gui-input {
            display: block;
            width: 100%;
            padding: 0.5rem; /* p-2 */
            font-size: 0.875rem; /* text-sm */
            color: #1f2937; /* gray-800 */
            background-color: #ffffff; /* bg-white */
            border: 1px solid #9ca3af; /* gray-400 */
             /* Classic bevel effect borders - slightly different for inset feel */
            border-top-color: #6b7280; /* gray-500 */
            border-left-color: #6b7280; /* gray-500 */
            border-bottom-color: #e5e7eb; /* gray-200 */
            border-right-color: #e5e7eb; /* gray-200 */
            border-radius: 0.25rem; /* rounded */
            transition: border-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            /* Spinners restored (no hiding rules) */
        }


        /* Custom focus style for inputs */
         .gui-input:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            /* Replicate Tailwind focus ring using box-shadow */
            box-shadow: 0 0 0 2px #ffffff, 0 0 0 4px #6366f1; /* ring-2 ring-indigo-500 ring-offset-2 */
            border-color: #6366f1; /* focus:border-indigo-500 */
         }
        /* --- End of Custom Input Styles --- */

        /* --- Custom CSS Button Styles --- */
        .gui-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem; /* Equivalent to px-4 py-2 */
            font-size: 0.875rem; /* Equivalent to text-sm */
            font-weight: 500; /* Equivalent to font-medium */
            color: #1f2937; /* gray-800 */
            background-color: #f3f4f6; /* gray-100 - Base solid color */
            border: 1px solid #9ca3af; /* gray-400 */
            /* Classic bevel effect borders */
            border-top-color: #e5e7eb; /* gray-200 */
            border-left-color: #e5e7eb; /* gray-200 */
            border-bottom-color: #6b7280; /* gray-500 */
            border-right-color: #6b7280; /* gray-500 */
            border-radius: 0.25rem; /* Equivalent to rounded */
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.1s ease-in-out, border-style 0.1s ease-in-out;
            /* Focus styles (Tailwind classes for consistency) */
            @apply focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2;
        }

        .gui-button:hover {
            background-color: #e5e7eb; /* gray-200 */
        }

        .gui-button:active {
            background-color: #d1d5db; /* gray-300 */
            border-style: inset; /* Inset border on click */
        }

        .gui-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Ensure icons align vertically */
         .gui-button .lucide {
             vertical-align: middle;
             margin-right: 0.3em; /* Slightly less margin */
         }
         /* Keep margin for modal secondary button */
         .modal-content button#cancel-import-sheet,
         .modal-content button#cancel-downsample-button,
         .modal-content button#cancel-save-button { /* Apply to all cancel buttons */
             margin-left: 0.75rem; /* ml-3 */
         }
         /* --- End of Custom Button Styles --- */

        /* Style for the message box */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 8px; /* More rounded */
            display: none; /* Hidden by default */
            z-index: 1050; /* Ensure it's above modal overlay */
            max-width: 90%;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Below message box, above content */
        }
        .modal-content {
            background-color: white;
            padding: 2rem; /* More padding */
            border-radius: 0.5rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 90vw; /* Limit width */
            max-height: 90vh; /* Limit height */
            overflow-y: auto; /* Allow scrolling if content overflows */
            width: 500px; /* Default width */
        }
        /* Reduce width for simpler modals */
        #downsample-modal .modal-content,
        #save-modal .modal-content { /* Apply to downsample and save modals */
            width: 400px;
        }
        .modal-content h2 {
             @apply text-xl font-semibold text-gray-900 mb-4;
        }
        /* Style for the preview canvas */
        #sprite-sheet-preview-canvas {
            max-width: 100%;
            border: 1px solid #d1d5db; /* gray-300 */
            margin-bottom: 1rem;
            display: block; /* Ensure it behaves like a block element */
            margin-left: auto; /* Center preview */
            margin-right: auto;
            background-color: #f8f8f8; /* Light background for canvas */
        }

        /* Selection Highlight */
        .selected-frame-highlight {
            position: absolute; /* Position relative to canvas container */
            border: 2px solid #4f46e5; /* Indigo-600 */
            box-shadow: 0 0 0 2px white; /* Inner white glow for contrast */
            pointer-events: none; /* Don't interfere with clicks */
            z-index: 10; /* Above images */
            /* Element is visible by default, hidden using the '.hidden' class */
        }


        /* Animation Preview Styles */
        #animation-preview-container {
            /* Removed top border, now part of the side-by-side layout */
        }
        #animation-preview-canvas {
            border: 1px solid #d1d5db; /* gray-300 */
            background-color: #f0f0f0; /* Slightly different background */
            display: block; /* Prevent extra space below */
            margin-left: auto; /* Center */
            margin-right: auto;
            margin-top: 0.5rem; /* Space below label */
            /* Display size will be set by JS */
        }

    </style>
    <style>
      /* Lucide Icon Font Setup */
      @font-face {
        font-family: 'LucideIcons';
        src: url(https://cdn.jsdelivr.net/npm/lucide-static@latest/font/Lucide.ttf) format('truetype');
      }
      .lucide {
        font-family: 'LucideIcons';
        font-style: normal;
        font-weight: normal;
        font-variant: normal;
        text-rendering: auto;
        line-height: 1;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        display: inline-block; /* Ensure proper alignment */
      }
      /* Map icon names to their Unicode characters */
      .lucide-upload::before { content: "\ef1b"; } /* upload icon */
      .lucide-save::before { content: "\ee9f"; }   /* save icon */
      .lucide-file-image::before { content: "\edc8"; } /* file-image icon */
      .lucide-trash-2::before { content: "\ef0b"; } /* trash-2 icon */
      .lucide-filter::before { content: "\edc1"; } /* filter icon */

    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="container mx-auto bg-white p-6 rounded-lg shadow-md">
        <h1 class="text-2xl font-semibold text-gray-900 mb-6 text-center">Sprite Sheet Editor</h1>

        <div class="control-panel grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 items-end">
            <div>
                <label for="grid-cols">Grid Columns:</label>
                <input type="number" id="grid-cols" class="gui-input" value="4" min="1">
            </div>
            <div>
                <label for="grid-rows">Grid Rows:</label>
                <input type="number" id="grid-rows" class="gui-input" value="4" min="1">
            </div>
            <div>
                <label for="frame-width">Frame Width (px):</label>
                <input type="number" id="frame-width" class="gui-input" value="64" min="1">
            </div>
            <div>
                <label for="frame-height">Frame Height (px):</label>
                <input type="number" id="frame-height" class="gui-input" value="64" min="1">
            </div>
            <div class="col-span-2 md:col-span-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mt-4">
                 <button id="import-frames-button" class="gui-button">
                    <span class="lucide lucide-upload"></span>Import Frames
                </button>
                 <button id="import-sheet-button" class="gui-button">
                    <span class="lucide lucide-file-image"></span>Import Sheet
                </button>
                 <button id="downsample-button" class="gui-button">
                    <span class="lucide lucide-filter"></span>Downsample
                 </button>
                 <button id="delete-frame-button" class="gui-button" disabled>
                     <span class="lucide lucide-trash-2"></span>Delete Frame
                 </button>
                <button id="save-button" class="gui-button"> <span class="lucide lucide-save"></span>Save Sprite Sheet
                </button>
            </div>
        </div>

        <input type="file" id="frame-file-input" multiple accept="image/*" class="hidden">
        <input type="file" id="sheet-file-input" accept="image/*" class="hidden">

        <div class="flex flex-col md:flex-row gap-6 mt-6">

            <div id="canvas-container-wrapper" class="flex-grow md:w-3/4 border border-gray-200 rounded-md p-3 bg-gray-50">
                 <p class="text-sm font-medium text-gray-700 mb-2 text-center">Sprite Sheet Canvas</p>
                 <div id="canvas-container" class="relative w-full overflow-auto border border-gray-300 rounded-md bg-gray-50">
                    <canvas id="sprite-canvas"></canvas>
                    <div id="selection-highlight" class="selected-frame-highlight hidden"></div>
                 </div>
            </div>

            <div id="animation-preview-container" class="md:w-1/4 border border-gray-200 rounded-md p-3 bg-gray-50 flex flex-col items-center">
                <label for="animation-preview-canvas" class="text-center block font-medium">Animation Preview</label>
                <canvas id="animation-preview-canvas" class="mt-2"></canvas>
                 <div class="mt-4 text-center">
                    <label for="animation-fps" class="text-sm text-gray-600 mr-2">FPS:</label>
                    <input type="number" id="animation-fps" class="gui-input inline-block w-16 text-center" value="10" min="1" max="60">
                </div>
            </div>

        </div>

        <div id="message-box"></div>

        <div id="import-sheet-modal" class="modal-overlay hidden">
             <div class="modal-content">
                 <h2>Import Sprite Sheet</h2>
                 <canvas id="sprite-sheet-preview-canvas"></canvas>
                 <p class="text-sm text-gray-600 mb-4">Adjust the grid dimensions or frame size. The other values will update automatically.</p>
                 <div class="grid grid-cols-2 gap-4">
                     <div>
                         <label for="import-sheet-cols">Grid Columns:</label>
                         <input type="number" id="import-sheet-cols" class="gui-input mb-3" value="4" min="1" step="1">
                     </div>
                     <div>
                         <label for="import-sheet-rows">Grid Rows:</label>
                         <input type="number" id="import-sheet-rows" class="gui-input mb-3" value="4" min="1" step="1">
                     </div>
                     <div>
                         <label for="import-sheet-width">Frame Width (px):</label>
                         <input type="number" id="import-sheet-width" class="gui-input mb-3" value="64" min="1" step="1">
                     </div>
                     <div>
                         <label for="import-sheet-height">Frame Height (px):</label>
                         <input type="number" id="import-sheet-height" class="gui-input mb-3" value="64" min="1" step="1">
                     </div>
                 </div>
                 <div class="mt-6 text-right">
                      <button id="cancel-import-sheet" class="gui-button">Cancel</button>
                      <button id="load-sheet-button" class="gui-button">Load Sprite Sheet</button>
                 </div>
             </div>
        </div>

        <div id="downsample-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>Downsample Frames</h2>
                <p class="text-sm text-gray-600 mb-4">Keep 1 out of every N frames in each row. Enter the value for N below (minimum 2).</p>
                <div>
                    <label for="downsample-ratio">Keep 1 / N frames (N):</label>
                    <input type="number" id="downsample-ratio" class="gui-input" value="2" min="2" step="1">
                </div>
                 <div class="mt-6 text-right">
                      <button id="cancel-downsample-button" class="gui-button">Cancel</button>
                      <button id="apply-downsample-button" class="gui-button">Apply Downsampling</button>
                 </div>
            </div>
       </div>

        <div id="save-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h2>Save Options</h2>
                <div class="mb-4">
                    <label for="save-filename">Base Filename:</label>
                    <input type="text" id="save-filename" class="gui-input" value="spritesheet">
                    <p class="text-xs text-gray-500 mt-1">`.png` extension will be added. If saving by row, `_rowN` will also be added.</p>
                </div>
                <div class="flex items-center mb-6">
                     <input id="save-by-row-checkbox" name="save-by-row" type="checkbox" class="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                     <label for="save-by-row-checkbox" class="ml-2 block text-sm text-gray-900">Save each row as a separate file</label>
                </div>
                 <div class="mt-6 text-right">
                      <button id="cancel-save-button" class="gui-button">Cancel</button>
                      <button id="confirm-save-button" class="gui-button">Save</button>
                 </div>
            </div>
       </div>


    </div> <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('sprite-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const ctx = canvas.getContext('2d');
        const gridColsInput = document.getElementById('grid-cols');
        const gridRowsInput = document.getElementById('grid-rows');
        const frameWidthInput = document.getElementById('frame-width');
        const frameHeightInput = document.getElementById('frame-height');
        const importFramesButton = document.getElementById('import-frames-button');
        const importSheetButton = document.getElementById('import-sheet-button');
        const saveButton = document.getElementById('save-button'); // Now opens modal
        const deleteFrameButton = document.getElementById('delete-frame-button');
        const frameFileInput = document.getElementById('frame-file-input');
        const sheetFileInput = document.getElementById('sheet-file-input');
        const messageBox = document.getElementById('message-box');
        const selectionHighlight = document.getElementById('selection-highlight');

        // Import Sheet Modal elements
        const importSheetModal = document.getElementById('import-sheet-modal');
        const modalPreviewCanvas = document.getElementById('sprite-sheet-preview-canvas');
        const modalPreviewCtx = modalPreviewCanvas.getContext('2d');
        let importSheetColsInput = document.getElementById('import-sheet-cols');
        let importSheetRowsInput = document.getElementById('import-sheet-rows');
        let importSheetWidthInput = document.getElementById('import-sheet-width');
        let importSheetHeightInput = document.getElementById('import-sheet-height');
        const cancelImportSheetButton = document.getElementById('cancel-import-sheet');
        const loadSheetButton = document.getElementById('load-sheet-button');

        // Animation Preview elements
        const animationPreviewCanvas = document.getElementById('animation-preview-canvas');
        const animationPreviewCtx = animationPreviewCanvas.getContext('2d');
        const animationFpsInput = document.getElementById('animation-fps');

        // Downsample Elements
        const downsampleButton = document.getElementById('downsample-button');
        const downsampleModal = document.getElementById('downsample-modal');
        const downsampleRatioInput = document.getElementById('downsample-ratio');
        const applyDownsampleButton = document.getElementById('apply-downsample-button');
        const cancelDownsampleButton = document.getElementById('cancel-downsample-button');

        // --- NEW: Save Modal Elements ---
        const saveModal = document.getElementById('save-modal');
        const saveFilenameInput = document.getElementById('save-filename');
        const saveByRowCheckbox = document.getElementById('save-by-row-checkbox');
        const confirmSaveButton = document.getElementById('confirm-save-button');
        const cancelSaveButton = document.getElementById('cancel-save-button');


        // --- State Variables ---
        let gridCols = parseInt(gridColsInput.value);
        let gridRows = parseInt(gridRowsInput.value);
        let frameWidth = parseInt(frameWidthInput.value);
        let frameHeight = parseInt(frameHeightInput.value);
        let placedImages = []; // Array to store { img, row, col, id } objects
        let nextImageId = 0;
        let selectedFrameId = null;
        let sourceSpriteSheetImage = null;

        // Modal Preview canvas state
        let modalPreviewScaleFactor = 1;
        let modalPreviewOffsetX = 0;
        let modalPreviewOffsetY = 0;
        let modalPreviewDrawnWidth = 0;
        let modalPreviewDrawnHeight = 0;
        let isUpdatingModalInputs = false;

        // Animation state
        let animationIntervalId = null;
        let currentAnimationFrameIndex = 0;
        let animationFps = parseInt(animationFpsInput.value);
        let framesToAnimate = [];

        // Drag and Drop State
        let isDragging = false;
        let dragMoved = false;
        let draggedImage = null;
        let dragStartCanvasX, dragStartCanvasY;
        let dragStartClientX, dragStartClientY;
        let dragOffsetX, dragOffsetY;


        // --- Utility Functions ---
        function showMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            if (messageBox.timeoutId) clearTimeout(messageBox.timeoutId);
            messageBox.timeoutId = setTimeout(() => {
                messageBox.style.display = 'none';
                messageBox.timeoutId = null;
            }, duration);
        }

        /**
         * Triggers a browser download for a given data URL and filename.
         * @param {string} dataURL - The data URL (e.g., from canvas.toDataURL()).
         * @param {string} filename - The desired filename for the download.
         */
        function triggerDownload(dataURL, filename) {
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }


        // --- Selection Highlight ---
        function updateSelectionHighlight() {
             if (!selectionHighlight) { console.error("Selection highlight element not found."); return; }
            if (selectedFrameId !== null) {
                const selectedItem = placedImages.find(item => item.id === selectedFrameId);
                if (selectedItem) {
                    selectionHighlight.style.left = `${selectedItem.col * frameWidth}px`;
                    selectionHighlight.style.top = `${selectedItem.row * frameHeight}px`;
                    selectionHighlight.style.width = `${frameWidth}px`;
                    selectionHighlight.style.height = `${frameHeight}px`;
                    selectionHighlight.classList.remove('hidden');
                    deleteFrameButton.disabled = false;
                    return;
                } else {
                    console.warn("Selected frame ID not found, deselecting.");
                    selectedFrameId = null;
                }
            }
            selectionHighlight.classList.add('hidden');
            deleteFrameButton.disabled = true;
        }

        // --- Canvas Drawing ---
        function drawGrid() {
             try {
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
                 ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1;
                 for (let i = 0; i <= gridCols; i++) {
                     const x = i * frameWidth; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
                 }
                 for (let i = 0; i <= gridRows; i++) {
                     const y = i * frameHeight; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
                 }
             } catch (e) { console.error("Error drawing grid:", e); showMessage("Error rendering grid.", 5000); }
        }

        function drawImages() {
             try {
                 canvas.style.cursor = 'default';
                 placedImages.forEach(item => {
                     const drawX = item.col * frameWidth; const drawY = item.row * frameHeight;
                     if (item?.img?.complete) {
                         if (!isDragging || item.id !== draggedImage?.id) {
                             ctx.drawImage(item.img, drawX, drawY, frameWidth, frameHeight);
                         }
                     } else if (item?.img) { // Image exists but not loaded
                         ctx.fillStyle = '#f3f4f6'; ctx.fillRect(drawX + 2, drawY + 2, frameWidth - 4, frameHeight - 4);
                         ctx.fillStyle = '#9ca3af'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '12px Inter';
                         ctx.fillText('Loading...', drawX + frameWidth / 2, drawY + frameHeight / 2);
                     }
                 });
                 if (isDragging && draggedImage?.img?.complete) {
                     ctx.globalAlpha = 0.6;
                     ctx.drawImage(draggedImage.img, dragStartCanvasX - dragOffsetX, dragStartCanvasY - dragOffsetY, frameWidth, frameHeight);
                     ctx.globalAlpha = 1.0; canvas.style.cursor = 'grabbing';
                 }
             } catch (e) {
                 console.error("Error drawing images:", e); showMessage("Error rendering images.", 5000);
                 if (isDragging) { isDragging = false; draggedImage = null; canvas.style.cursor = 'default'; }
             }
        }

        function redrawCanvas() {
             try {
                 const newCanvasWidth = gridCols * frameWidth;
                 const newCanvasHeight = gridRows * frameHeight;

                 if (newCanvasWidth <= 0 || newCanvasHeight <= 0 || !Number.isFinite(newCanvasWidth) || !Number.isFinite(newCanvasHeight)) {
                     console.warn("Skipping redraw: invalid dimensions", newCanvasWidth, newCanvasHeight);
                     if (canvas.width > 0 && canvas.height > 0) ctx.clearRect(0, 0, canvas.width, canvas.height);
                     animationPreviewCanvas.width = 1; animationPreviewCanvas.height = 1;
                     animationPreviewCanvas.style.width = `1px`; animationPreviewCanvas.style.height = `1px`;
                     animationPreviewCtx.clearRect(0, 0, 1, 1); stopAnimation(); return;
                 }

                 if (canvas.width !== newCanvasWidth || canvas.height !== newCanvasHeight) {
                     canvas.width = newCanvasWidth; canvas.height = newCanvasHeight;
                 }

                 const currentPreviewWidth = frameWidth > 0 ? frameWidth : 1;
                 const currentPreviewHeight = frameHeight > 0 ? frameHeight : 1;
                 if (animationPreviewCanvas.width !== currentPreviewWidth || animationPreviewCanvas.height !== currentPreviewHeight) {
                    animationPreviewCanvas.width = currentPreviewWidth;
                    animationPreviewCanvas.height = currentPreviewHeight;
                    animationPreviewCanvas.style.width = `${currentPreviewWidth}px`;
                    animationPreviewCanvas.style.height = `${currentPreviewHeight}px`;
                 }

                 drawGrid();
                 drawImages();
                 updateSelectionHighlight();

             } catch (e) { console.error("Error in redrawCanvas:", e); showMessage("Error updating canvas.", 5000); }
        }

        // --- Event Handlers ---
        function handleSizeChange() {
            const newCols = parseInt(gridColsInput.value); const newRows = parseInt(gridRowsInput.value);
            const newFrameW = parseInt(frameWidthInput.value); const newFrameH = parseInt(frameHeightInput.value);
            if (isNaN(newCols) || isNaN(newRows) || isNaN(newFrameW) || isNaN(newFrameH) || newCols < 1 || newRows < 1 || newFrameW < 1 || newFrameH < 1) {
                showMessage("Invalid size: values must be positive numbers.");
                gridColsInput.value = gridCols; gridRowsInput.value = gridRows; frameWidthInput.value = frameWidth; frameHeightInput.value = frameHeight; return;
            }
            gridCols = newCols; gridRows = newRows; frameWidth = newFrameW; frameHeight = newFrameH;
            const oldSelectedId = selectedFrameId;
            placedImages = placedImages.filter(item => item.row < gridRows && item.col < gridCols);
            if (oldSelectedId !== null && !placedImages.some(item => item.id === oldSelectedId)) { selectedFrameId = null; }
            redrawCanvas();
            startAnimation();
        }

        // --- Frame Import ---
        function handleImportFramesClick() { frameFileInput.click(); }
        function handleFrameFileSelect(event) {
            const files = event.target.files; if (!files || files.length === 0) return;
            let imagesSuccessfullyLoaded = 0, imagesFailedToLoad = 0; const totalFiles = files.length;
            let slotsAvailable = (gridRows * gridCols) - placedImages.length;
            function findNextAvailableSlot() { for (let r = 0; r < gridRows; r++) for (let c = 0; c < gridCols; c++) if (!placedImages.some(img => img.row === r && img.col === c)) return { row: r, col: c }; return null; }
            if (totalFiles > slotsAvailable) showMessage(`Warning: ${totalFiles} files selected, only ${slotsAvailable} slots available.`, 5000);
            Array.from(files).forEach((file) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = () => {
                        const slot = findNextAvailableSlot();
                        if (slot) {
                            placedImages.push({ img: img, row: slot.row, col: slot.col, id: nextImageId++ });
                            imagesSuccessfullyLoaded++; redrawCanvas(); startAnimation();
                        } else { imagesFailedToLoad++; console.warn(`No slot for ${file.name}.`); }
                        if (imagesSuccessfullyLoaded + imagesFailedToLoad === totalFiles) showMessage(`Frame import: ${imagesSuccessfullyLoaded} loaded, ${imagesFailedToLoad} skipped.`, 4000);
                    };
                    img.onerror = () => { console.error(`Failed load frame: ${file.name}`); imagesFailedToLoad++; if (imagesSuccessfullyLoaded + imagesFailedToLoad === totalFiles) showMessage(`Frame import: ${imagesSuccessfullyLoaded} loaded, ${imagesFailedToLoad} skipped.`, 5000); };
                    img.src = e.target.result;
                };
                reader.onerror = () => { console.error(`Failed read frame file: ${file.name}`); imagesFailedToLoad++; if (imagesSuccessfullyLoaded + imagesFailedToLoad === totalFiles) showMessage(`Frame import: ${imagesSuccessfullyLoaded} loaded, ${imagesFailedToLoad} skipped.`, 5000); };
                reader.readAsDataURL(file);
            });
            frameFileInput.value = '';
        }

        // --- Sprite Sheet Import ---
        function handleImportSheetClick() { sheetFileInput.click(); }
        function updateModalPreviewGridAndInputs(changedInputId) {
            if (isUpdatingModalInputs || !sourceSpriteSheetImage?.complete) return;
            isUpdatingModalInputs = true;
            const currentCols = parseInt(importSheetColsInput.value); const currentRows = parseInt(importSheetRowsInput.value);
            const currentWidth = parseInt(importSheetWidthInput.value); const currentHeight = parseInt(importSheetHeightInput.value);
            const imgWidth = sourceSpriteSheetImage.width; const imgHeight = sourceSpriteSheetImage.height;
            try {
                if (changedInputId === 'import-sheet-cols' || changedInputId === 'import-sheet-rows') { if (currentCols > 0 && currentRows > 0) { const newFrameW = Math.floor(imgWidth / currentCols); const newFrameH = Math.floor(imgHeight / currentRows); if (newFrameW > 0 && !isNaN(newFrameW)) importSheetWidthInput.value = newFrameW; if (newFrameH > 0 && !isNaN(newFrameH)) importSheetHeightInput.value = newFrameH; } }
                else if (changedInputId === 'import-sheet-width' || changedInputId === 'import-sheet-height') { if (currentWidth > 0 && currentHeight > 0) { const newCols = Math.floor(imgWidth / currentWidth); const newRows = Math.floor(imgHeight / currentHeight); if (newCols > 0 && !isNaN(newCols)) importSheetColsInput.value = newCols; if (newRows > 0 && !isNaN(newRows)) importSheetRowsInput.value = newRows; } }
            } catch (e) { console.error("Error during modal dimension recalculation:", e); }
            try {
                modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height);
                modalPreviewCtx.drawImage(sourceSpriteSheetImage, modalPreviewOffsetX, modalPreviewOffsetY, modalPreviewDrawnWidth, modalPreviewDrawnHeight);
                const finalCols = parseInt(importSheetColsInput.value); const finalRows = parseInt(importSheetRowsInput.value);
                const finalFrameW = parseInt(importSheetWidthInput.value); const finalFrameH = parseInt(importSheetHeightInput.value);
                if (isNaN(finalCols) || isNaN(finalRows) || isNaN(finalFrameW) || isNaN(finalFrameH) || finalCols < 1 || finalRows < 1 || finalFrameW < 1 || finalFrameH < 1) { console.warn("Invalid dimensions for modal preview grid."); isUpdatingModalInputs = false; return; }
                const previewFrameW = finalFrameW * modalPreviewScaleFactor; const previewFrameH = finalFrameH * modalPreviewScaleFactor;
                modalPreviewCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; modalPreviewCtx.lineWidth = 1;
                for (let i = 1; i < finalCols; i++) { const x = modalPreviewOffsetX + i * previewFrameW; modalPreviewCtx.beginPath(); modalPreviewCtx.moveTo(x, modalPreviewOffsetY); modalPreviewCtx.lineTo(x, modalPreviewOffsetY + modalPreviewDrawnHeight); modalPreviewCtx.stroke(); }
                for (let i = 1; i < finalRows; i++) { const y = modalPreviewOffsetY + i * previewFrameH; modalPreviewCtx.beginPath(); modalPreviewCtx.moveTo(modalPreviewOffsetX, y); modalPreviewCtx.lineTo(modalPreviewOffsetX + modalPreviewDrawnWidth, y); modalPreviewCtx.stroke(); }
            } catch (e) { console.error("Error drawing modal preview grid:", e); }
            isUpdatingModalInputs = false;
        }
        function handleSheetFileSelect(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                sourceSpriteSheetImage = new Image();
                sourceSpriteSheetImage.onload = () => {
                    const maxWidth = 450; const maxHeight = 300;
                    const imgWidth = sourceSpriteSheetImage.width; const imgHeight = sourceSpriteSheetImage.height;
                    const widthScale = maxWidth / imgWidth; const heightScale = maxHeight / imgHeight;
                    modalPreviewScaleFactor = Math.min(widthScale, heightScale, 1);
                    modalPreviewDrawnWidth = imgWidth * modalPreviewScaleFactor; modalPreviewDrawnHeight = imgHeight * modalPreviewScaleFactor;
                    modalPreviewCanvas.width = modalPreviewDrawnWidth > 0 ? modalPreviewDrawnWidth : maxWidth;
                    modalPreviewCanvas.height = modalPreviewDrawnHeight > 0 ? modalPreviewDrawnHeight : maxHeight;
                    modalPreviewOffsetX = (modalPreviewCanvas.width - modalPreviewDrawnWidth) / 2; modalPreviewOffsetY = (modalPreviewCanvas.height - modalPreviewDrawnHeight) / 2;
                    modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height);
                    modalPreviewCtx.drawImage(sourceSpriteSheetImage, modalPreviewOffsetX, modalPreviewOffsetY, modalPreviewDrawnWidth, modalPreviewDrawnHeight);
                    const aspect = imgWidth / imgHeight; let guessCols = 4, guessRows = 4;
                    if (aspect > 1.5 && imgHeight > 0) { guessCols = 8; guessRows = Math.max(1, Math.round(8 / aspect)); } else if (aspect < 0.6 && imgWidth > 0) { guessRows = 8; guessCols = Math.max(1, Math.round(8 * aspect)); }
                    let guessFrameW = (guessCols > 0) ? Math.floor(imgWidth / guessCols) : imgWidth; let guessFrameH = (guessRows > 0) ? Math.floor(imgHeight / guessRows) : imgHeight;
                    if (guessFrameW <= 0) guessFrameW = 1; if (guessFrameH <= 0) guessFrameH = 1;
                    if (guessCols <= 0) guessCols = Math.max(1, Math.floor(imgWidth / guessFrameW)); if (guessRows <= 0) guessRows = Math.max(1, Math.floor(imgHeight / guessFrameH));
                    importSheetColsInput.value = guessCols; importSheetRowsInput.value = guessRows; importSheetWidthInput.value = guessFrameW; importSheetHeightInput.value = guessFrameH;
                    const newColsInput = importSheetColsInput.cloneNode(true); importSheetColsInput.parentNode.replaceChild(newColsInput, importSheetColsInput); importSheetColsInput = newColsInput;
                    const newRowsInput = importSheetRowsInput.cloneNode(true); importSheetRowsInput.parentNode.replaceChild(newRowsInput, importSheetRowsInput); importSheetRowsInput = newRowsInput;
                    const newWidthInput = importSheetWidthInput.cloneNode(true); importSheetWidthInput.parentNode.replaceChild(newWidthInput, importSheetWidthInput); importSheetWidthInput = newWidthInput;
                    const newHeightInput = importSheetHeightInput.cloneNode(true); importSheetHeightInput.parentNode.replaceChild(newHeightInput, importSheetHeightInput); importSheetHeightInput = newHeightInput;
                    importSheetColsInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-cols')); importSheetRowsInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-rows')); importSheetWidthInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-width')); importSheetHeightInput.addEventListener('input', () => updateModalPreviewGridAndInputs('import-sheet-height'));
                    updateModalPreviewGridAndInputs(null); importSheetModal.classList.remove('hidden');
                };
                sourceSpriteSheetImage.onerror = () => { showMessage("Error: Could not load image file.", 5000); sourceSpriteSheetImage = null; };
                sourceSpriteSheetImage.src = e.target.result;
            }
            reader.onerror = () => { showMessage("Error: Could not read file.", 5000); }
            reader.readAsDataURL(file); sheetFileInput.value = '';
        }
        function handleCancelImportSheet() {
            importSheetModal.classList.add('hidden'); sourceSpriteSheetImage = null;
            modalPreviewCtx.clearRect(0, 0, modalPreviewCanvas.width, modalPreviewCanvas.height);
            const cleanCols = importSheetColsInput.cloneNode(true); importSheetColsInput.parentNode.replaceChild(cleanCols, importSheetColsInput); importSheetColsInput = cleanCols; const cleanRows = importSheetRowsInput.cloneNode(true); importSheetRowsInput.parentNode.replaceChild(cleanRows, importSheetRowsInput); importSheetRowsInput = cleanRows; const cleanWidth = importSheetWidthInput.cloneNode(true); importSheetWidthInput.parentNode.replaceChild(cleanWidth, importSheetWidthInput); importSheetWidthInput = cleanWidth; const cleanHeight = importSheetHeightInput.cloneNode(true); importSheetHeightInput.parentNode.replaceChild(cleanHeight, importSheetHeightInput); importSheetHeightInput = cleanHeight;
        }
        function handleLoadSpriteSheet() {
            const importCols = parseInt(importSheetColsInput.value); const importRows = parseInt(importSheetRowsInput.value);
            const importFrameW = parseInt(importSheetWidthInput.value); const importFrameH = parseInt(importSheetHeightInput.value);
            if (isNaN(importCols) || isNaN(importRows) || isNaN(importFrameW) || isNaN(importFrameH) || importCols < 1 || importRows < 1 || importFrameW < 1 || importFrameH < 1) { showMessage("Invalid dimensions.", 4000); return; }
            if (!sourceSpriteSheetImage?.complete) { showMessage("Error: Source image missing.", 4000); return; }
            if (importCols * importFrameW > sourceSpriteSheetImage.width + 5 || importRows * importFrameH > sourceSpriteSheetImage.height + 5) { if (!confirm(`Warning: Dimensions might exceed image size. Continue?`)) { return; } }
            console.log(`Loading: ${importCols}x${importRows} frames, ${importFrameW}x${importFrameH}px.`); showMessage("Processing sheet...", 10000);
            gridColsInput.value = importCols; gridRowsInput.value = importRows; frameWidthInput.value = importFrameW; frameHeightInput.value = importFrameH;
            handleSizeChange(); placedImages = []; nextImageId = 0; selectedFrameId = null;
            const promises = [];
            for (let r = 0; r < importRows; r++) { for (let c = 0; c < importCols; c++) { const sx = c * importFrameW; const sy = r * importFrameH; const framePromise = new Promise((resolve, reject) => { const frameCanvas = document.createElement('canvas'); frameCanvas.width = importFrameW; frameCanvas.height = importFrameH; const frameCtx = frameCanvas.getContext('2d'); try { frameCtx.drawImage(sourceSpriteSheetImage, sx, sy, importFrameW, importFrameH, 0, 0, importFrameW, importFrameH); const frameImg = new Image(); frameImg.onload = () => resolve({ img: frameImg, row: r, col: c }); frameImg.onerror = (err) => { console.error(`Err load frame [${r}, ${c}]`, err); reject(`Failed load ${r}-${c}`); }; frameImg.src = frameCanvas.toDataURL('image/png'); } catch (e) { console.error(`Err draw frame [${r}, ${c}]`, e); reject(`Failed draw ${r}-${c}`); } }); promises.push(framePromise); } }
            Promise.all(promises)
                .then((loadedFramesData) => { placedImages = loadedFramesData.map(data => ({ img: data.img, row: data.row, col: data.col, id: nextImageId++ })); console.log("Frames processed."); redrawCanvas(); startAnimation(); showMessage(`Sheet loaded! ${loadedFramesData.length} frames.`, 4000); })
                .catch((error) => { console.error("Error processing:", error); showMessage(`Error loading: ${error}.`, 5000); redrawCanvas(); startAnimation(); })
                .finally(() => { handleCancelImportSheet(); });
        }

        // --- Save Handlers ---

        /**
         * Opens the Save Options modal.
         */
        function handleSaveClick() {
            if (placedImages.length === 0) {
                showMessage("Nothing to save.");
                return;
            }
            // Reset modal state
            saveFilenameInput.value = "spritesheet";
            saveByRowCheckbox.checked = false;
            // Show modal
            saveModal.classList.remove('hidden');
        }

        /**
         * Hides the Save Options modal.
         */
        function hideSaveModal() {
            saveModal.classList.add('hidden');
        }

        /**
         * Executes the save operation based on modal options.
         */
        function executeSave() {
            const baseFilename = saveFilenameInput.value.trim() || "spritesheet";
            const saveByRow = saveByRowCheckbox.checked;

            hideSaveModal(); // Hide modal immediately

            if (saveByRow) {
                saveSheetByRow(baseFilename);
            } else {
                saveEntireSheet(baseFilename);
            }
        }

        /**
         * Saves the entire sprite sheet as a single PNG file.
         * @param {string} filename - The base filename (without extension).
         */
        function saveEntireSheet(filename) {
             console.log("Saving entire sheet as:", filename);
             if (placedImages.length === 0) { showMessage("Nothing to save."); return; } // Double check

             const fullFilename = filename.toLowerCase().endsWith('.png') ? filename : filename + '.png';

             const tempCanvas = document.createElement('canvas');
             try {
                 const requiredWidth = gridCols * frameWidth;
                 const requiredHeight = gridRows * frameHeight;
                 if (requiredWidth <= 0 || requiredHeight <= 0) { showMessage("Cannot save: Invalid dimensions."); return; }
                 tempCanvas.width = requiredWidth; tempCanvas.height = requiredHeight;
                 const tempCtx = tempCanvas.getContext('2d');
                 let imagesDrawn = 0;
                 placedImages.forEach(item => {
                     if (item?.img?.complete) {
                         try {
                             tempCtx.drawImage(item.img, item.col * frameWidth, item.row * frameHeight, frameWidth, frameHeight);
                             imagesDrawn++;
                         } catch (e) { console.error(`Error drawing image ID ${item.id} during save:`, e); }
                     } else { console.warn(`Skipping unloaded/invalid image ID ${item?.id} during save.`); }
                 });
                 if (imagesDrawn === 0 && placedImages.length > 0) { showMessage("Error: Could not draw any loaded images.", 5000); return; }

                 const dataURL = tempCanvas.toDataURL('image/png');
                 triggerDownload(dataURL, fullFilename); // Use helper function
                 showMessage(`Saved sheet as ${fullFilename}! (${imagesDrawn} frames)`);
             } catch (e) {
                 console.error("Error saving entire sheet:", e);
                 showMessage("An error occurred while saving the sheet. Check console.", 5000);
             }
        }

        /**
         * Saves each row of the sprite sheet as a separate PNG file.
         * @param {string} baseFilename - The base filename (without extension or suffix).
         */
        function saveSheetByRow(baseFilename) {
            console.log("Saving sheet by row, base filename:", baseFilename);
            if (placedImages.length === 0) { showMessage("Nothing to save."); return; } // Double check

            let filesSavedCount = 0;
            let maxRow = -1;
            placedImages.forEach(img => { if (img.row > maxRow) maxRow = img.row; });

            if (maxRow < 0) {
                showMessage("No rows found to save separately.");
                return;
            }

            try {
                for (let r = 0; r <= maxRow; r++) {
                    // Get frames for the current row and sort by column
                    const rowFrames = placedImages
                        .filter(item => item.row === r)
                        .sort((a, b) => a.col - b.col);

                    if (rowFrames.length === 0) {
                        continue; // Skip empty rows
                    }

                    // Create a temporary canvas for this row
                    const rowSheetWidth = rowFrames.length * frameWidth;
                    const rowSheetHeight = frameHeight;
                    if (rowSheetWidth <= 0 || rowSheetHeight <= 0) {
                         console.warn(`Skipping row ${r}: Invalid dimensions calculated.`);
                         continue;
                    }

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = rowSheetWidth;
                    tempCanvas.height = rowSheetHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    let imagesDrawnThisRow = 0;

                    // Draw frames for this row onto the temp canvas
                    rowFrames.forEach((item, index) => {
                         if (item?.img?.complete) {
                            try {
                                tempCtx.drawImage(item.img, index * frameWidth, 0, frameWidth, frameHeight);
                                imagesDrawnThisRow++;
                            } catch (e) { console.error(`Error drawing image ID ${item.id} for row ${r} save:`, e); }
                         } else { console.warn(`Skipping unloaded/invalid image ID ${item?.id} for row ${r} save.`); }
                    });

                    if (imagesDrawnThisRow > 0) {
                        // Generate filename and trigger download
                        const filename = `${baseFilename}_row${r}.png`;
                        const dataURL = tempCanvas.toDataURL('image/png');
                        triggerDownload(dataURL, filename); // Use helper function
                        filesSavedCount++;
                    } else {
                         console.warn(`Skipping save for row ${r}: No images could be drawn.`);
                    }
                } // End row loop

                if (filesSavedCount > 0) {
                    showMessage(`Saved ${filesSavedCount} row file(s) starting with '${baseFilename}'.`);
                } else {
                    showMessage("No rows with drawable frames found to save.");
                }

            } catch (e) {
                 console.error("Error saving sheet by row:", e);
                 showMessage("An error occurred while saving rows separately. Check console.", 5000);
            }
        }


        // --- Delete Handler ---
        function handleDeleteSelected() {
             if (selectedFrameId === null) { showMessage("No frame selected."); return; }
             const index = placedImages.findIndex(item => item.id === selectedFrameId);
             if (index !== -1) { const deletedItem = placedImages.splice(index, 1)[0]; console.log(`Deleted ID ${selectedFrameId}`); selectedFrameId = null; redrawCanvas(); startAnimation(); showMessage("Frame deleted."); }
             else { showMessage("Selected frame not found."); selectedFrameId = null; updateSelectionHighlight(); }
        }

        // --- Drag and Drop & Selection Logic ---
        function getMousePos(canvasEl, evt) { const rect = canvasEl.getBoundingClientRect(); const clientX = evt.clientX ?? evt.touches?.[0]?.clientX; const clientY = evt.clientY ?? evt.touches?.[0]?.clientY; if (typeof clientX !== 'number' || typeof clientY !== 'number') { console.warn("No mouse pos."); return null; } return { x: clientX - rect.left, y: clientY - rect.top }; }
        function handleMouseDown(event) {
             const pos = getMousePos(canvas, event); if (!pos) return; if (event.type === 'touchstart') event.preventDefault();
             dragStartCanvasX = pos.x; dragStartCanvasY = pos.y; dragStartClientX = event.clientX ?? event.touches?.[0]?.clientX; dragStartClientY = event.clientY ?? event.touches?.[0]?.clientY; dragMoved = false;
             const clickedCol = Math.floor(pos.x / frameWidth); const clickedRow = Math.floor(pos.y / frameHeight);
             if (clickedCol < 0 || clickedCol >= gridCols || clickedRow < 0 || clickedRow >= gridRows || frameWidth <= 0 || frameHeight <= 0) { if (selectedFrameId !== null) { selectedFrameId = null; redrawCanvas(); startAnimation(); } draggedImage = null; isDragging = false; return; }
             const clickedImage = placedImages.find(item => item.row === clickedRow && item.col === clickedCol);
             if (clickedImage) { draggedImage = clickedImage; isDragging = false; dragOffsetX = pos.x - (draggedImage.col * frameWidth); dragOffsetY = pos.y - (draggedImage.row * frameHeight); canvas.style.cursor = 'grab'; if (selectedFrameId !== clickedImage.id) { selectedFrameId = clickedImage.id; redrawCanvas(); startAnimation(); } }
             else { draggedImage = null; isDragging = false; canvas.style.cursor = 'default'; if (selectedFrameId !== null) { selectedFrameId = null; redrawCanvas(); startAnimation(); } }
        }
        function handleMouseMove(event) {
             if (!draggedImage) return; const currentX = event.clientX ?? event.touches?.[0]?.clientX; const currentY = event.clientY ?? event.touches?.[0]?.clientY; if (typeof currentX !== 'number' || typeof currentY !== 'number') return; const moveThreshold = 5;
             if (!isDragging && (Math.abs(currentX - dragStartClientX) > moveThreshold || Math.abs(currentY - dragStartClientY) > moveThreshold)) { isDragging = true; dragMoved = true; canvas.style.cursor = 'grabbing'; console.log("Drag start ID:", draggedImage.id); redrawCanvas(); }
             if (isDragging) { if (event.type === 'touchmove') event.preventDefault(); const pos = getMousePos(canvas, event); if (!pos) return; dragStartCanvasX = pos.x; dragStartCanvasY = pos.y; redrawCanvas(); }
        }
        function handleMouseUp(event) {
            const wasDragging = isDragging; const currentlyDragged = draggedImage;
            if (isDragging) {
                isDragging = false; canvas.style.cursor = 'default'; let requiresAnimationUpdate = false;
                const pos = getMousePos(canvas, event);
                if (pos && frameWidth > 0 && frameHeight > 0 && currentlyDragged) {
                    const targetCol = Math.floor(pos.x / frameWidth); const targetRow = Math.floor(pos.y / frameHeight);
                    if (targetCol >= 0 && targetCol < gridCols && targetRow >= 0 && targetRow < gridRows) {
                        const existingImage = placedImages.find(item => item.row === targetRow && item.col === targetCol && item.id !== currentlyDragged.id);
                        if (!existingImage) { if (currentlyDragged.row !== targetRow) requiresAnimationUpdate = true; currentlyDragged.row = targetRow; currentlyDragged.col = targetCol; selectedFrameId = currentlyDragged.id; console.log(`Drop ID ${currentlyDragged.id} at [${targetRow}, ${targetCol}]`); }
                        else { showMessage("Target occupied."); console.log(`Drop fail ID ${currentlyDragged.id}: target [${targetRow}, ${targetCol}] occupied`); selectedFrameId = currentlyDragged.id; }
                    } else { showMessage("Dropped outside grid."); console.log(`Drop fail ID ${currentlyDragged.id}: outside grid`); selectedFrameId = currentlyDragged.id; }
                } else { console.warn("Could not get drop location."); if(currentlyDragged) selectedFrameId = currentlyDragged.id; }
                draggedImage = null; redrawCanvas(); if (requiresAnimationUpdate || selectedFrameId !== null) startAnimation();
            } else if (currentlyDragged && !dragMoved) { console.log(`Click ID ${currentlyDragged.id}. Sel state: ${selectedFrameId}`); canvas.style.cursor = 'grab'; }
            else if (!currentlyDragged) { canvas.style.cursor = 'default'; }
            if (!isDragging) draggedImage = null; dragMoved = false;
        }
        function handleMouseLeave(event) {
             if (isDragging) { const previouslyDragged = draggedImage; isDragging = false; draggedImage = null; canvas.style.cursor = 'default'; redrawCanvas(); showMessage("Drag cancelled."); console.log(`Drag cancel ID ${previouslyDragged?.id}`); if(previouslyDragged) selectedFrameId = previouslyDragged.id; startAnimation(); }
             else if (canvas.style.cursor === 'grab') { canvas.style.cursor = 'default'; }
        }

        // --- Animation Functions ---
        function stopAnimation() { if (animationIntervalId !== null) { clearInterval(animationIntervalId); animationIntervalId = null; } }
        function runAnimationLoop() {
            if (animationPreviewCanvas.width <= 0 || animationPreviewCanvas.height <= 0) { stopAnimation(); return; }
            if (!framesToAnimate || framesToAnimate.length === 0) { animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height); return; }
            const currentFrameData = framesToAnimate[currentAnimationFrameIndex];
            animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height);
            if (currentFrameData?.img?.complete) { try { animationPreviewCtx.drawImage(currentFrameData.img, 0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height); } catch (e) { console.error("Error drawing animation frame:", e); animationPreviewCtx.fillStyle = 'red'; animationPreviewCtx.fillText('!', animationPreviewCanvas.width / 2, animationPreviewCanvas.height / 2); } }
            else { animationPreviewCtx.fillStyle = '#9ca3af'; animationPreviewCtx.textAlign = 'center'; animationPreviewCtx.textBaseline = 'middle'; animationPreviewCtx.fillText('...', animationPreviewCanvas.width / 2, animationPreviewCanvas.height / 2); }
            currentAnimationFrameIndex = (currentAnimationFrameIndex + 1) % framesToAnimate.length;
        }
        function startAnimation() {
            stopAnimation();
            const selectedItem = selectedFrameId !== null ? placedImages.find(item => item.id === selectedFrameId) : null;
            if (selectedItem) { framesToAnimate = placedImages.filter(item => item.row === selectedItem.row).sort((a, b) => a.col - b.col); }
            else { framesToAnimate = [...placedImages].sort((a, b) => a.row - b.row || a.col - b.col); }
            currentAnimationFrameIndex = 0;
            if (framesToAnimate.length > 0 && animationFps > 0) { const intervalDelay = 1000 / animationFps; animationIntervalId = setInterval(runAnimationLoop, intervalDelay); }
            else { animationPreviewCtx.clearRect(0, 0, animationPreviewCanvas.width, animationPreviewCanvas.height); }
        }
        function handleFpsChange() {
            const newFps = parseInt(animationFpsInput.value);
            if (!isNaN(newFps) && newFps >= 1 && newFps <= 60) { animationFps = newFps; console.log(`Animation FPS changed to: ${animationFps}`); startAnimation(); }
            else { animationFpsInput.value = animationFps; showMessage("Invalid FPS value (1-60).", 4000); }
        }

        // --- Downsample Functions ---
        function showDownsampleModal() {
            if (placedImages.length === 0) { showMessage("No frames loaded to downsample."); return; }
            downsampleRatioInput.value = "2"; downsampleModal.classList.remove('hidden');
        }
        function hideDownsampleModal() { downsampleModal.classList.add('hidden'); }
        function handleApplyDownsample() {
            const ratioN = parseInt(downsampleRatioInput.value);
            if (isNaN(ratioN) || ratioN < 2) { showMessage("Invalid downsample ratio (>= 2).", 4000); return; }
            if (placedImages.length === 0) { showMessage("No frames to downsample."); hideDownsampleModal(); return; }
            console.log(`Downsampling with ratio N = ${ratioN}`);
            const downsampledImages = []; let maxColsNeeded = 0; let maxRow = -1;
            placedImages.forEach(img => { if (img.row > maxRow) maxRow = img.row; });
            for (let r = 0; r <= maxRow; r++) {
                const rowFrames = placedImages.filter(item => item.row === r).sort((a, b) => a.col - b.col);
                if (rowFrames.length === 0) continue;
                let newColIndex = 0;
                for (let i = 0; i < rowFrames.length; i++) {
                    if (i % ratioN === 0) { const frameToKeep = rowFrames[i]; frameToKeep.col = newColIndex; downsampledImages.push(frameToKeep); newColIndex++; }
                }
                maxColsNeeded = Math.max(maxColsNeeded, newColIndex);
            }
            const originalCount = placedImages.length; placedImages = downsampledImages; const newCount = placedImages.length;
            const newGridCols = newCount > 0 ? Math.max(1, maxColsNeeded) : parseInt(gridColsInput.value);
            if (newGridCols !== gridCols) { gridCols = newGridCols; gridColsInput.value = gridCols; console.log(`Grid columns updated to ${gridCols}`); }
            if (selectedFrameId !== null && !placedImages.some(item => item.id === selectedFrameId)) { selectedFrameId = null; }
            redrawCanvas(); startAnimation(); hideDownsampleModal();
            showMessage(`Downsampling complete. Kept ${newCount}/${originalCount} frames. Grid cols set to ${gridCols}.`, 5000);
        }


        // --- Event Listeners ---
        gridColsInput.addEventListener('change', handleSizeChange);
        gridRowsInput.addEventListener('change', handleSizeChange);
        frameWidthInput.addEventListener('change', handleSizeChange);
        frameHeightInput.addEventListener('change', handleSizeChange);
        animationFpsInput.addEventListener('change', handleFpsChange);

        importFramesButton.addEventListener('click', handleImportFramesClick);
        importSheetButton.addEventListener('click', handleImportSheetClick);
        frameFileInput.addEventListener('change', handleFrameFileSelect);
        sheetFileInput.addEventListener('change', handleSheetFileSelect);
        saveButton.addEventListener('click', handleSaveClick); // MODIFIED: Opens modal now
        deleteFrameButton.addEventListener('click', handleDeleteSelected);

        // Modal Listeners (Import Sheet)
        cancelImportSheetButton.addEventListener('click', handleCancelImportSheet);
        loadSheetButton.addEventListener('click', handleLoadSpriteSheet);

        // Downsample Listeners
        downsampleButton.addEventListener('click', showDownsampleModal);
        cancelDownsampleButton.addEventListener('click', hideDownsampleModal);
        applyDownsampleButton.addEventListener('click', handleApplyDownsample);

        // --- NEW: Save Modal Listeners ---
        cancelSaveButton.addEventListener('click', hideSaveModal);
        confirmSaveButton.addEventListener('click', executeSave);

        // Canvas Listeners
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseLeave);
        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleMouseUp);
        canvas.addEventListener('touchcancel', handleMouseLeave);


        // --- Initial Setup ---
        redrawCanvas();
        startAnimation();
        console.log("Sprite Sheet Editor Initialized.");

    </script>

</body>
</html>
